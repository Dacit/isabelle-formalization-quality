10. All steps are clear, and the proof is quite simple.Another example:lemma (in Order) less_and_segment:"b ∈ carrier D ⟹      (∀a
3, because the definition of eq_onpE is not very readable, it is difficult to see the connection between the lemma and the lemma tagged with the lemma tag.If we want to improve the quality, we can do many things:\begin{itemize}\item \textbf{Avoid redundant definitions}: The definition of eq_onpE is not really needed, we can just have the lemma \textit{eq_onp}.\item \textbf{Avoid redundant lemmata}: The lemma tagged with a lemma tag is not really needed, we can just have the lemma tagged with a lemma tag \textit{case_unit_parametric}.\item \textbf{Use more descriptive definitions}: For example, the lemma \textit{case_unit_parametric} could be improved by replacing the definition of \textit{case_unit} by the definition of \textit{case_unit_parametric} (more understandable).\item \textbf{Add a proof of correctness}: The correctness proof of the lemma \textit{eq_onp} is not given.\end{itemize}Quality assessment is still an open
6.The problems are that it is hard to read, the proofs are not immediately clear, and it does not provide any indication of its correctness.Besides, it is missing some definitions and lemmas that are supposed to be true:\begin{itemize}\item what is the result of `mergeMany`?\item what is the result of `toBallot`?\item what is the result of `hashToUnique`?\end{itemize}The Isabelle formalization of Merkle trees is rather bad, for various reasons. It needs to be fixed.The following snippet is the way it is supposed to look like:\begin{code}locale MerkleTrees =  fixes 'a = "type'a"    and h :: "('a, 'a) hash"    and b :: "('a, 'a) blinding_of"    and m :: "('a, 'a) merge"  assumes hash_respects_hashes: "hash_of_hash = 'a hash \<Rightarrow> 'a hash = 'a hash"    and
5.Let us now see how we could improve the quality of this snippet.First, I would change the definition of bo_def:bo_def \<equiv> "\<lambda>(x, y) (a, b). if a \<noteq> b then True else a = b"This is clearer, because it states that bo is true iff the first argument equals the second argument.The definition of transp:transp \<equiv> "\<lambda>(x, y) (a, b). a = b"Now I can clearly see that transp is the identity function, which I can assume without proof.However, I would need to think a bit about the definition of reflp:reflp \<equiv> "\<lambda> (a, b). (a = b \<and> b = a)"I could maybe make it even clearer and use the new definitions of bo_def and transp.\begin{code}lemma reflp: "('a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> bool) \<Rightarrow> boolreflp 'a\<^sub>m \<
2.\end{code}For example, the lemma `equivclp_least[OF hash]` is a bit cryptic and I would prefer something more explicit and readable.\strong{Question}: Is there a way to write a prover configuration that emphasizes the quality of the formalization?I am using SMTLIB 2.4.5, Isabelle 2018.3.5, and Coq 8.7.0.Comment: I'm not sure that the SMTLIB code makes any significant difference here.  The `equivclp_least` call is just the implementation of the `equivclp_least` tactic, which is designed to work with *both* SMTLIB and Isabelle.  The actual transformation used to do the proof is based on Isabelle's SMT-based proof infrastructure.Comment: To write clearer proofs, I find it useful to use the Isabelle proof assistant's built-in theorem prover first.  This makes the proofs easier to read and also helps with larger proofs.  The downside of this approach is that the Isabelle proof assistant
3.### Verifying the quality of a proofTo verify that a proof is well-written, I can use the checker [https://isabelle.in.tum.de/system/files/logic/isabelle/checker/Isabelle2019-tutorial-checker.pdf](Isabelle2019-tutorial-checker.pdf) that was created by Moritz and Walter.This is similar to the PVS proof checker but has a wider range of checks, such as construsive well-foundedness checking.### Verifying the correctness of a proofIdeally, I would like to use the [https://isabelle.in.tum.de/system/files/logic/isabelle/checker/Isabelle2019-tutorial-checker.pdf](Isabelle2019-tutorial-checker.pdf) for this but the problem is that I don't know the correctness of my own proof.I am hoping that there is some way to use Isabelle to automatically verify the correctness of a proof.
6.\hypertarget{points}{In a formalization, points can be assessed using the following system.}Let us look at the formalization of this snippet.\hypertarget{formalization}{We start with a description of the type of the elements that we are using:}\begin{hscode}\SaveRestoreHook\column{B}{@{}>{\hspre}l<{\hspost}@{}}%\column{E}{@{}>{\hspre}l<{\hspost}@{}}%\>[0]\;\;\;\;\;{}\<[1]%\>[0]{}\textbf{record}\;\; bo :: "(\<lambda>x. f x) \<Rightarrow> bool"\<[1]%\>[0]{}\textbf{where}\;\; {}\<[2]%\>[2]{}\mbox{bo f = f (bo f)}\<[3]%\>[3]{}\mbox{bo \<circ> f = f (bo f) bo f}\<[4]%\>[4]{}\mbox{bo f \<circ> g
5 for this snippet.Why do I give it a 5?\begin{itemize}\item The definitions are readable, but could be even better.\item The proof does not follow the style of Isabelle/HOL, and makes some things like types harder to read.\item It has some bugs (as can be seen by the excerpted examples).\end{itemize}The first point has to do with the fact that many FLs have a different style of defining things. The Isabelle/HOL style of defining is this:\begin{code}lemma blinding_respects_hashes:  "('a\<^sub>m \<Rightarrow> 'a\<^sub>h) \<Rightarrow> ('a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> bool) \<Rightarrow> boolblinding_respects_hashes 'a\<^sub>m \<Rightarrow> 'a\<^sub>hh 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> boolbo"  by(induction "hash") (auto simp add: boolbo_def_aux)
20.\end{code}Comment: The proof assistant is just a tool, and it can have its own version of the rules of inference. What you have here is a proof of soundness. If you want to check for completeness, you can check every proof in the formalization and see if they all are correct.Comment: What you have here is a proof of soundness. If you want to check for completeness, you can check every proof in the formalization and see if they all are correct.Comment: The thing is that I don't want to check every proof in the formalization, I want to check every proof in Isabelle, and Isabelle proves that it is correct. Isn't that enough?Comment: I agree, but Isabelle should be able to prove that it is correct.Comment: @GuidoG, you don't *need* to check every proof in Isabelle, you just need to check that every proof in Isabelle is actually sound. The tool gives you soundness, and you are not forced to check all proofs.Comment: @GuidoG, @Gilles, you are right about completen
5.We'd really like a way to provide feedback on the quality of formalizations.*///exerciselemma merge_on_subset: "x \<in> vmap y \<Longrightarrow> merge y x \<circ> f = merge x (y \<circ> f) \<longleftrightarrow> merge (y \<circ> f) x = f \<circ> (merge y x)"  apply (simp add: merge_def)  apply (subst (asm) (dest: same join undefined))  donelemma merge_on_subset': "x \<in> vmap y \<Longrightarrow> merge y x = merge x (y \<circ> f) \<longleftrightarrow> merge (y \<circ> f) x = f \<circ> (merge y x)"  apply (simp add: merge_def)  apply (subst (asm) (dest: same join undefined))  donelemma merge_on_subset'': "x \<in> vmap y \<Longrightarrow> merge y x = merge x (y \<circ> f) \<longleftrightarrow> merge (y \<circ> f) x = f
6. There are some things we would change if we could do it again, but it is hard to make it perfect.(* ##################################################### *)(** * Exercise *)(** Find an example of a definition that is hard to understand. *)Definition ax = ax_def(** If we want to use the [Fact] tactic to prove this definition, we    need to write [Fact ax] instead of [Fact ax_def]! *)Theorem factorial_eq_refl :  "x \<le> (fun n => n) = true"  by(simp add: factorial_eq_def)(* ####################################################### *)(** * Exercise *)(** Let's use the [Fact] tactic to prove this lemma: *)Theorem factorial_eq_1 : "x = (fun n => n) \<longleftrightarrow> true"proof -  assume "x = (fun n => n)"  then have "true = (fun n => n) (n + 1)"    by simp  then have "
4.Unfortunately, only the part"show idem: "'a \<Rightarrow> 'a \<Rightarrow> 'a optionm 'aa 'aa = 'a \<Rightarrow> 'a optionSome 'aa" for a by(simp add: same)"is wrong.The reason for this is that the inference rule"simp add: same" was not used in the proof.This is why we need Isabelle/HOL's interactive mode:We can interrupt a proof and get advice on how to proceed.Furthermore, Isabelle/HOL can do a lot of preprocessing,such as finding the simplest proofs, giving suggestions,and checking that the proof is correct.(This makes Isabelle/HOL a lot more like a human proof assistant than a simple theorem prover.)We can also use the command"redo" to start a fresh proof.If Isabelle/HOL cannot prove the proof goal, it willask for a specific lemma to be proved and help us do so."""use_cases :: Example  (a \<Rightarrow> b) (a \<Rightarrow> b) (a
7. In the next section we will take a closer look at the metrics we are using.\subsection{Metrics}There are many metrics we can use to evaluate the quality of a formalization.These metrics are somewhat subjective, however there are some metrics we will be using in this paper to evaluate the quality of our formalizations.\subsubsection{Understandability}When assessing the understandability of a formalization we want to be able to tell how easy it is to understand the formalization.\subsubsection{Maintainability}The quality of a formalization is improved by reducing the amount of work that is required to maintain it.\subsubsection{Usage}We want to be able to use the formalization to prove interesting results.\subsubsection{Complexity}We want to formalize as much as possible in the simplest way.\subsubsection{Reduce Debugging}Even if a formalization is correct, if it is too hard to debug then it is not worth formalizing.\subsection{Metrics}The following metrics will be used in this paper:\begin
6. The extra unused lemmas could be filled in and the proof could be simplified by using the rewrite rules available in the Isabelle theory library.\end{blockquote}Answer: Is this something like what you're looking for?\begin{code}lemma merkle_interface [simp]:  "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> 'a option) \<Rightarrow> boolmerge_on 'a setUNIV 'a \<Rightarrow> 'bh 'a \<Rightarrow> 'a \<Rightarrow> boolbo 'a \<Rightarrow> 'a \<Rightarrow> 'a optionm"  by (auto simp add: idem join' split: bool_split[symmetric])\end{code}Answer: I'm not familiar with Isabelle, but I suppose you could try to define a "fresh" variable for each lemma you want to prove. Here's the code for the `def` lemma I used in Coq, where `V` is a fresh variable.\begin{code}
3.## How Isabelle assesses the quality of formalizationsIsabelle comes with a [tool](http://www.cs.indiana.edu/~fl/qt/qt.html) which allows you to take a formalization and write some code which will check its quality. You should use this tool.## The quality of a formalization of a specificationIsabelle can check the quality of a formalization, but it is a hard problem. You should use the quality-checking tool [Qt](http://www.cs.indiana.edu/~fl/qt/qt.html) to check your formalization. The quality-checking tool is a separate tool and does not require Isabelle.## The quality of a formalization of an implementationIn addition to the above, you can also use the quality-checking tool [Happy](http://www.cs.indiana.edu/~fl/happy.html) to check that your implementation (in Isabelle) complies with the specification (in Isabelle).## The quality of a formalization of a proofIt is important to note that the quality-checking tools can only
9.5.Here is another example which is arguably incorrect:elegibility_keys_parametric[transfer_rule]:[<parametric_constant of_public_key>]: (  [<parametric_constant of_private_key>]: (    [<parametric_constant of_public_key>]  ))This is very short, but it has an obvious bug. Assuming that `of_public_key` and `of_private_key` are correctly defined, the last line states that `(of_public_key)` is `of_private_key`. There is a reason why we say `if X then Y else Z` instead of just `if X then Y`.The second example is a proof of correctness, which is a proof that does not meet our standards of correctness. It is neither correct nor incorrect, and it is not even a proof of correctness.A correct proof of correctness is the following:elegibility_keys_parametric[transfer_rule]:  [<parametric_constant of_public_key>
3. It is difficult to write a good formalization that is both clear and maintainable, and that is understood by everyone in the team.However, you can always improve it.For example, I would have included an explanation of the parameter 'a', its type and its use.Also, I would have put the definitions and lemmas in separate files.Finally, a comment that says the definition and lemma are not used would be useful.When assessing the quality of an Isabelle formalization, we can always be totally assured that it is correct.However, quality can vary: Formalizations need to be understandable, maintainable, and easy to use.Unclear definitions, proofs that are too hard to follow, and proofs that are likely to break with future changes are all problematic and should be avoided.Let us take the following snippet as an example:by unfold_locales(auto simp add: merge_discrete_def)lemma merkle_discrete [locale_witness]:  "('a \<Rightarrow> 'a) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('
1. It is a little difficult to understand and will be harder to maintain. It is not easy to use.\section{Useful features}\subsection{Comprehensions}One of the most useful features in Isabelle/HOL is comprehensions.Comprehensions are not the only tool for defining new inductive types.There are also quantified type definitions, and parametric type definitions. However, comprehensions are more powerful and often require fewer lines of code.This is a comprehension:\begin{code}inductive "a: Nat \<Rightarrow> Nat"  {struct a = a\<^sub>1 \<le> a\<^sub>2 \<le> ... \<le> a\<^sub>k}\end{code}It defines a new type, `a: Nat \<Rightarrow> Nat`, which is a list of natural numbers. The key is to understand that we are using `a` as a variable in the body of the definition.This is a comprehension with a recursive definition:\begin{code}inductive "a: Nat \<Rightarrow> Nat"  {
4.Also, I would prefer that it would be possible to write the full definition in one place, e.g., a formalization of a set of functions, which would make it easier to maintain the definition, as well as to quickly see if there were any problems. """from isabelle import *from isabelle.pretty.simple_pretty import sformat#https://github.com/isabelle/Isabelle2018/blob/master/src/contrib/isabelle/pretty/simple_pretty/isabelle.ml#L1991defformals = '''structure CAT (A : Type) : Type :=  { C : A -> A -> A  , r : forall x y z, C x y z -> z = C x y z  , l : forall x y z, C x y z -> z = x = y = z  }'''#let funs = list_of(sformat(defformals))#define funs(f) f#define funs(x,y) x
5.What could be improved here?\begin{itemize}\item The function `hash_blindable' is not introduced, and therefore its type is not defined. We want to make sure that we do not need to guess the type of a function that is used in a proof.\item The context is not introduced. We want to make sure that we do not need to guess the names of the lemmas that are used in a proof.\item The name of the induction principle is not introduced. The use of the word "induction" should be an indication for the induction principle used.\end{itemize}To fix these problems, we can add a few definitions and lemmas:\begin{code}lemma "hash_blindable_def = hash_blindable'_parametric"  by (auto simp: hash_blindable'_def simp_all add: hash_blindable_def)lemma "hash_blindable'_def = hash_blindable_parametric"  by (auto simp: hash_blindable'_def simp_all add: hash_blind
5: It is possible to understand it, it is easy to use, and it does not break when you make a change to the Isabelle library.But, for this snippet, there is a better way to formalize it that is also correct.Instead of writing the lemma as a separate lemma, we can just use the `base` `inductive` and put all the lemmas in one place.\begin{code}inductive_simps base_lemma:  "('a\<^sub>m, 'a\<^sub>h) blindable\<^sub>m \<Rightarrow> ('a\<^sub>m, 'a\<^sub>h) blindable\<^sub>m \<Rightarrow> boolblinding_of_blindable ('a\<^sub>m \<Rightarrow> ('a\<^sub>m, 'a\<^sub>h) blindable\<^sub>mUnblinded 'a\<^sub>mx) ('a\<^sub>m, 'a\<^sub>h) blindable\<^sub>my"  "('a\<^sub>m, 'a\<^sub>h) blindable\<^sub>m \<Rightarrow> ('a\<^
5: the proof is still a little bit hard to follow, and it is likely to break if someone modifies a definition or a lemma somewhere else.Now, let us look at the same snippet, but with a more informative (and so more readable) formalization:\begin{code}lemma blinding_of_blindable_mono' :  assumes "'a \<Rightarrow> 'a \<Rightarrow> boolbo \<le> 'a \<Rightarrow> 'a \<Rightarrow> boolbo'"  shows "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a, 'b) blindable\<^sub>m \<Rightarrow> ('a, 'b) blindable\<^sub>m \<Rightarrow> boolblinding_of_blindable 'a \<Rightarrow> 'bh 'a \<Rightarrow> 'a \<Rightarrow> boolbo \<le> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a, 'b) blindable\<^sub>m \<Rightarrow> ('a, 'b) blindable\<^sub>m \<
6.Given this fragment, we have no assurance about the quality of the proofs.How can we assess the quality of the formalization?\begin{enumerate}\item \textbf{Usefulness:} How useful is the formalization? Does it provide a lot of lemmas?\item \textbf{Understandability:} How hard is it to understand?\item \textbf{Maintainability:} How easy is it to extend?\item \textbf{Extensibility:} Can it be extended to other domains?\end{enumerate}Because Isabelle is designed to formally prove programs,its main application is in software development.For this reason, we need to be able to write proofs that are not just mathematically sound, but also easy to read and understand.In addition, we want to be able to produce other Isabelle documents from our formalizations,and to change our formalization without breaking previously-proven theorems.\subsection{Understandability}The best way to write a proof is to write it in a way that is comprehensible to humans.However, Isabelle's proof language
3.As a concrete example, I tried to formalize the following function (from the Data.Set.Unboxed.Binary.Std library):\begin{code}insert' :: (Ord a, Iso (Map a) (Map b)) => a -> (Map a, Map b) -> (Map a, Map b)insert' key x = (x1', x2') where  x1' = insert' key (x1, x2)  x2' = insert' key (x1, x2)\end{code}The code and formalization are below. I am not going to include the entire formalization. The key thing to notice is that we have two functions `insert'` (unboxed and boxed) and that `insert'` takes two arguments, the first being the key and the second being the existing map.\begin{code}theory "Data.Set.Unboxed.Binary.Std"imports "Data.Set.Unboxed.Binary.Std"imports "Data.Set.Unboxed.Binary.Std"variable "insert
5.However, one may find the above snippet verbose, and I agree. Let us rewrite it as follows:lemma blinding_of_blindable [simp]:  "('a, 'b) blindable\<^sub>mx = ('a, 'b) blindable\<^sub>my" if    "('a, 'b) blindable\<^sub>m \<Rightarrow> ('a, 'b) blindable\<^sub>m \<Rightarrow> bool?bo ('a, 'b) blindable\<^sub>mx ('a, 'b) blindable\<^sub>my"    "('a, 'b) blindable\<^sub>mx \<in> ('a, 'b) blindable\<^sub>m set?A"    "x \<in> A \<and> y \<in> A \<and> x = y"    "h x \<le> y \<and> h y \<le> x \<and> (x, y) \<notin> A"proof -  have that: "h x \<le> y \<and> h y \<le> x \<and> (x, y) \<notin> A \<
7.The lemma mentions several undefined types and functions, and even though we can always safely assume that they are defined somewhere in the Isabelle proof, it is not easy to find. Furthermore, the name of the lemma is not helpful in understanding the lemma and its uses.Our goal is to transform this into a high quality formalization. To do so, we first have to understand the problem, which is not obvious from the syntax of the source code. We have to be able to identify the various parts of the specification, and trace through them. Then we have to find the correct formalization for each part, and then we have to connect them in a way that makes sense.Such an exercise would be easy if all specifications were in one language, but it is challenging with a specification like Isabelle's, which uses several languages:\begin{itemize}\item Isabelle's language (function and data definitions, imports, ...);\item mathematical formulas (using the \texttt{misc} language);\item informal descriptions (using the \texttt{text} language);\item code (using \texttt{isabelle} language).\end{
9, for now.\begin{itemize}\item \textbf{Understandability:} This is pretty self-explanatory. I believe that this snippet is easily understandable.\item \textbf{Maintainability:} This is also pretty self-explanatory. However, I would have to ask myself whether there are problems with the \texttt{interpret} function that might arise when I use it in the future.\item \textbf{Easy to use:} This is slightly less clear. It is not hard to use, as this snippet is very small. However, I think that the question of whether it is easy to use is more of a long term concern. For example, can I easily edit this in the future? Or, should I feel that there are problems with the types or assumptions of the function?\end{itemize}So I give this snippet a \textbf{5}.\section{Formalization}In this section, I will present a formalization of a state machine that I have developed in the Isabelle proof assistant.\subsection{Introduction}Let us start with an example of a state machine.\begin
5.The Isabelle community has a general philosophy of writing the most correct proofs first, and they often write proofs that are too long or contain too many details. The only thing that is certain is that a proof is correct.\section{Writing good Isabelle code}In general, writing good Isabelle code is a combination of two things:\begin{itemize}\item \em{Knowing what Isabelle can do}\item \em{Being able to \strong{apply it correctly}.}\end{itemize}Isabelle is very powerful.  However, its expressiveness is also its downside: Isabelle is more complex than Haskell, and it is more difficult to come up with a general proof about a programming language.This can be fixed by learning Isabelle and its tools better. Isabelle comes with an interactive editor, called [Isabelle-mode](https://github.com/isaacjohnson/Isabelle-mode), that makes it very easy to write Isabelle code. When writing Isabelle code, \strong{we can also use Haskell as a programming language.}To help people learn
7.\begin{blockquote}\begin{itemize}  \item \strong{Understandable}: A formalization should be easily understandable. If you have to spend too much time understanding it, it is probably not correct. This is especially true for proofs that are hard to read.\end{itemize}\end{blockquote}How can we test understandability?\begin{blockquote}\begin{itemize}  \item \strong{Maintainable}: A formalization should be easy to maintain. Ideally, a single command should be enough to understand a piece of code and to modify it.\end{itemize}\end{blockquote}This is hard to test since we do not want to make such formalizations too strict.\begin{blockquote}\begin{itemize}  \item \strong{Easy to use}: A formalization should be easy to use. A large formalization should be broken up into smaller pieces.\end{itemize}\end{blockquote}This is difficult to test too.Can anyone give me an idea how to test these
10. The proof is quite hard to follow.If you have a better idea of how to write the proof, please feel free to contribute to the Isabelle development community.However, I am looking for ideas on how to improve the quality of the proof.Comment: It seems that the last lemma is missing a hypotheses.Comment: Oops, yes. Thanks.Answer: Isabelle has a theorem prover, which means that it can prove formalizations (i.e. proofs) in a strict way, i.e. it can prove that one formalization implies another.In your snippet, the proof is shown as a sequence of theorems.In general, this is fine and it can be a good way to show a proof.However, if you want to prove that a formalization is correct (i.e. that it follows the corresponding informal description), then this way of showing proofs is not the best.Instead, you can use the theorem prover to show that the formalization is consistent with the corresponding informal description.For example, the lemma `is_empty_list` can be proven using the theorem pro
7.Since we are working on a formalization of the "real" Merkle tree, we know that we can safely ignore the additional assumptions and use them to make our formalization easier to read and understand.For example, we could rewrite the definition of the hash function using the induction principle, and we could define the binary operations on the type in a more explicit manner, but since we know that the structure is not modified, we can afford to sacrifice clarity here.Note also that we could have used a notation like this, but we are here for a reason.let hash_nr_blindable = "({}'a, {}'a) blindable\<^sub>m"let blinding_of_nr_blindable = "('a, 'a) blindable\<^sub>m \<Rightarrow> ('a, 'a) blindable\<^sub>m \<Rightarrow> boolblinding_of_nr_blindable"let merge_nr_blindable = "('a, 'a) blindable\<^sub>m \<Rightarrow> ('a, 'a) blindable\<^sub>m \<Rightarrow> boolmerge_nr_blindable
1. It is very hard to read, it is full of redundant definitions and lemmas, and the proofs are not correct.What can we do?We can improve the quality of the formalization by making it easier to read, more understandable, and easier to maintain.Let us look at an example.Let us say that we want to formalize the following snippet:```lemma merkle_nr_blindable:  "(('a, 'a) blindable\<^sub>m \<Rightarrow> 'a blindable\<^sub>h) \<Rightarrow> (('a, 'a) blindable\<^sub>m \<Rightarrow> ('a, 'a) blindable\<^sub>m \<Rightarrow> bool) \<Rightarrow> (('a, 'a) blindable\<^sub>m \<Rightarrow> ('a, 'a) blindable\<^sub>m \<Rightarrow> ('a, 'a) blindable\<^sub>m option) \<Rightarrow> bool"  ..```We can improve this snippet by making it more readable.First, let us rename some of the named variables.```lemma merkle_
7,because some definitions are not very clear,and because I am not sure whether the definitions are sound.For example, what exactly is the type of the hash_sum function?It depends on the type of 'a and 'b (the definitions of 'a and 'b have not been given).The documentation would help.We can improve the quality of the definition by giving a better description,which should make it clearer what the function does. For example, we can say:abbreviation (input) hash_sum' :: "(type'a\<^sub>h +\<^sub>h type'b\<^sub>h, type'a\<^sub>h +\<^sub>h type'b\<^sub>h) hash" where  "'a\<^sub>h + 'b\<^sub>h \<Rightarrow> 'a\<^sub>h + 'b\<^sub>hhash_sum' \<equiv> 'a\<^sub>h + 'b\<^sub>h \<Rightarrow> 'a\<^sub>h + 'b\<^sub>hid"This is better. It is still not as good as it could be though:The abbreviation is too
3.\subsection{Quality metrics}We can measure the quality of an Isabelle formalization by looking at some of the following dimensions:\begin{enumerate}\item \textit{Understandability} is the readability of the formalization. Is it easy to see where it goes wrong? Is it clear what the assumptions and conclusions are?\item \textit{Maintainability} is the ease with which you can change your formalization.\item \textit{Efficiency} is how fast your Isabelle session runs.\item \textit{Correctness} is whether your formalization is actually correct.\end{enumerate}An Isabelle formalization can be made \textit{more understandable} by introducing proper terminology, and making the definitions easier to read and understand.It can be made \textit{more maintainable} by separating the actual definition of the theory into smaller pieces.A formalization can be made \textit{more efficient} by removing unused assertions and using the best type system available.And it can be made \textit{correct} by using the right constructs and the correct number of them.
2.\end{blockquote}\begin{blockquote}\begin{itemize}  \item Is the definition for a lemma correct?\end{itemize}\end{blockquote}The definition is correct. For example, if there is an element `x` in the set `a` of the form `(e1 a)` and there is an element `y` in the set `c` of the form `(e1 c)` such that `x = y`, then the definition says that the two elements are equal.\begin{blockquote}\begin{itemize}  \item Is the proof correct?\end{itemize}\end{blockquote}The proof is correct. If the definitions and lemmas are correct, then the proof is correct.\begin{blockquote}\begin{itemize}  \item Is the quality of the formalization good?\end{itemize}\end{blockquote}The quality is not good. The definitions and lemmas are not too bad, but the proof is too long. This is an example of a bad quality formalization.
5.\medskipWe can still make it better, as follows:\begin{code}by fact  interpret b: blinding_of_on 'c set'c setB 'c \<Rightarrow> 'd'c \<Rightarrow> 'drhb 'c \<Rightarrow> 'c \<Rightarrow> bool'c \<Rightarrow> 'c \<Rightarrow> boolbob by fact  show bool?thesis  proof    show "'a + 'c \<Rightarrow> 'a + 'c \<Rightarrow> bool?bo 'a + 'cx 'a + 'cx" if "'a + 'cx \<in> ('a + 'c) set?A" for x using that by(intro sum.rel_refl_strong)(auto intro: a.refl b.refl)    show "'a + 'c \<Rightarrow> 'a + 'c \<Rightarrow> bool?bo 'a + 'cx 'a + 'cz" if "'a + 'c \<Rightarrow> 'a + 'c \<Rightarrow> bool?bo 'a + 'cx 'a + 'cy" "'a + 'c \<Rightarrow> 'a + 'c \<
6.With this snippet we can see that the lemma uses two different notation for the same type: the `a\<^sub>m set and the `a\<^sub>m option.The lemma also assumes that there is a function \texttt{mergeOn} for the \texttt{bool} type, which is not in the code.We can therefore extract the following from the lemma:\begin{itemize}\item There is a type \texttt{bool}\item There is a function \texttt{boolmerge\_on} for a set of \texttt{bool}s\item There is a function \texttt{boolmerge\_on\_sum} that takes an \texttt{a\<^sub>m set} and an \texttt{a\<^sub>m} and returns a \texttt{bool}.\end{itemize}Looking at the type of \texttt{boolmerge\_on\_sum}, we can see that it is of type \texttt{boolmerge\_on} \texttt{a\<^sub>m set} \texttt{a\<^sub>m},which means that the function only applies to \texttt{a\<^sub>m}s.
7.\end{document}\end{code}Comment: You mean, on a scale from 0 to 10. I've edited the example accordingly.Comment: How do you propose to get more information about the quality of a formalization?Comment: @egreg I am looking for a more systematic approach to formalization quality. The best way I can think of is to ask more experienced users to evaluate the formalization. But I think there should be an easier way, don't you?Comment: I'd like to see a tool that could automatically score some quality aspects. For example, if it's not the case that, at the end of the proof, the assumptions and the conclusion are the same, the proof is probably not correct. If the definitions of the predicates are not well separated from the assumptions and the conclusion, the proof is probably not correct. If the definition of a predicate uses too many synonyms or is too long, the proof is probably not correct. If the proof is not very clear and contains a lot of trivial or obvious lemmas, the proof is probably not correct.Comment: @cfr I think
2.\end{code}The key to the right quality is to make sure you use the proper techniques. In this case, the author uses `cases` to construct the proof of `merge_sum`, which is the correct choice. However, the code should have been annotated with `unfold`s for readability, as well as `dest` and `elim` annotations to make it clear that only a `dest` is needed to show that the proof is complete.When writing proof obligations, I would also like to see the proof goals written like `lemma merge_sum_alt_def` rather than just `merge_sum_alt_def`.\section{Rule names}I would make sure to use short names for the rules in the `using` clauses. In this case, they are `merge_on_sum`, `merge_sum`, `merge_on_sum_alt` and `merge_sum_alt`.\section{Readability}This snippet of code has a lot of information that is not directly relevant to the proof being given.\begin{code}lemma merge_sum_alt_def:
6.\strong{What would be your rating of this snippet? What would you do to improve it?}There are several obvious things we can do to improve it:\begin{itemize}\item \strong{Improve documentation.}It is perfectly acceptable to not have a lot of documentation in a formalization. However, a formalization with no documentation would probably score poorly in a contest.\item \strong{Use documentation from a good formalization.}Having lots of formalization templates that are specific to a problem (like that of merkle trees) is a good idea. If you are not sure how to express a lemma, look at similar ones.\item \strong{Use documentation from the Isabelle standard library.}The standard library contains a lot of documentation about how to use and formalize with Isabelle. We should be using it to its full potential.\item \strong{Use specialized formalization templates.}Isabelle has several [formalization templates](http://www. Isabelle.org/homepage/formalization.html) that should be used to their full potential. In this case, we could have used
5.This is what Isabelle tries to improve. The author of the definition might want to add more information, but not only the author of the definition:We can also check that we are not accidentally using an ambiguous symbol:\begin{lstlisting}lemma a1: "a(a, b, c) = a(a, b, c)"\end{lstlisting}In the above snippet, we are looking for a lemma that ensures that a given function is injective. We are given the definition of this function as a named type (a function takes two arguments), then it is applied to some arbitrary arguments.We can write down the following definitions:\begin{lstlisting}definition a :: "nat \<Rightarrow> nat \<Rightarrow> bool" where  "a (Suc n) (Suc m) = False"| "a n m = True"\end{lstlisting}Now we can prove the following lemma:\begin{lstlisting}lemma a1: "a(a, b, c) = a(a, b, c)"\end{lstlist
5. It is not very intuitive and not easy to read.However, if Isabelle has to prove a certain theorem in a more complex context, then the quality of the formalization can change dramatically. In the following example, we use the axiom of choice to prove the soundness of our decision procedure.lemma soundness_of_decision_procedure_with_axiom_of_choice:  assumes decidable: "decidable_procedure (int :: 'a) (int :: 'a) (int :: 'a)"  assumes exist_decidable: "decidable_procedure (int :: 'a) (int :: 'a) (int :: 'a)"  assumes decidable_and_decidable_with_axiom_of_choice: "decidable_procedure (int :: 'a) (int :: 'a) (int :: 'a) \<longleftrightarrow> decidable_procedure (int :: 'a) (int :: 'a) (int :: 'a)"  shows decidable_procedure (int :: 'a) (int :: 'a) (int :: 'a)
4. The proof is clear. However, there is a lot of repetition, even within the same definition:defining blinding_of_on_prod[where x = (x, y)                        , y = (y, z)                        , y = z                        , z = (z, w)                        , z = w                        , w = (w, u)                        , w = u                        , u = (u, v)                        , u = v                        , v = (v, a)                        , v = a](use assms; simp)lemma blinding_of_on_prod [where x = (x, y)                        , y = (y, z)                        , y = z                        , z = (z, w)                        , z = w                        , w = (w, u)                        , w = u                        , u = (u, v)                        , u = v                        , v = (v, a)                        , v = a] 
4. It is clear what is going on, but it could be much clearer.Now, let us take the same proof and formally state it in Isabelle. For this we need to use the \ref{snippet} tactic to convert the above proof to an Isabelle proof.\begin{hscode}\SaveRestoreHook\column{B}{@{}>{\hspre}l<{\hspost}@{}}%\column{E}{@{}>{\hspre}l<{\hspost}@{}}%\>[B]{}\langle\!\langle {*} \rangle\!\rangle{}\<[2]%\>[2]{}\textbf{Theorem}\;\mathop{\mathsf{B}} :: "('a \<times> 'c) set?A \<Rightarrow> bool \<Rightarrow> bool"\;\text{\upshape{,}}\;\>[3]{}\textbf{where}\;\>[4]{}\mathop{\mathsf{B}} \<equiv> \<lambda>\>[5]{}\mbox{}"\<a> \<times> \<c> \<in> \<^{*}a> \<times> \<^{*}c> set?
3. As you can see, there is a lot of information, but it is hard to read, and it is not easy to use.Let us take the following snippet as an example:\begin{verbatim}lemmas merge_on_prod [locale_witness] =    merge_on_prod_1 [where A = "a setUNIV and B = "b setUNIV, simplified]    merge_on_prod_2 [where A = "a setUNIV and B = "b setUNIV, simplified]    merge_on_prod_3 [where A = "a setUNIV and B = "b setUNIV, simplified]\end{verbatim}\begin{verbatim}definition merge_on_prod (A : a setUNIV) (B : b setUNIV)    : a setUNIV    := a option \<Rightarrow>        (A \<times> B) optionOption.bind        (fun a :: a setUNIV.            fun b :: b setUNIV.            fun ab :: (a setUNIV \<times> b
6. The proof looks a bit hard to follow, and there are missing definitions. The author probably assumed that the reader already understood what merge_on does.The next snippet is the same, but much better in quality:lemma merge_on_lemma:  fix a :: 'a, b :: 'b  assume a\<^sub>m \<le> b\<^sub>m  assume a\<^sub>m \<le> {!a\<^sub>m}  assume a\<^sub>m \<le> {!a\<^sub>m} \<and> b\<^sub>m \<le> {!b\<^sub>m}  assume b\<^sub>m \<le> {!b\<^sub>m} \<and> a\<^sub>m \<le> {!a\<^sub>m} \<and> b\<^sub>m \<le> {!b\<^sub>m}  assume a\<^sub>m \<le> {!a\<^sub>m} \<and> a\<^sub>m \<le> {!a\<^sub>m} \<and> b\<^sub>m \<le> {!b\<^sub>m}
2, because I did not take care to write the definitions in such a way that they are both readable and succinct.However, this is not very important as this is only a sample snippet. What is important is that this is a correct, precise, and easy to understand formalization. The Isabelle proof assistant has an undecidable formalization problem, i.e. there is no decidable formalization problem.In order to formally verify our proof, we therefore need to prove that this is an undecidable problem, i.e. that there is no way to systematically assess the quality of a formalization.Answer: The fact that there is no decidable formalization problem is not a problem in itself. The problem is that Isabelle proofs are difficult to read (which makes it difficult to do anything with them), and even if we could read them, we cannot prove them correct. There are two reasons for that.First, Isabelle proof style is problematic. The way proofs are written is not very intuitive for humans and, more importantly, it makes it very difficult to write proof rules that are easily automated.Second, the fundamental problem of Isabelle proofs is
6.\begin{itemize}\item It's understandable.\item The proofs are easy to follow and the example is well chosen.\item As it is used in the Isabelle manual, the lemma is probably not likely to break with future changes.\end{itemize}\section{Writing more complex formalizations}We can formalize more complex programs, but we will need to make some choices.\section{Functions}We can formalize functions using the \verb|fun_def| tactic.\begin{lstlisting}fun_def 1 f n = f(1::'a) :: 'a list\end{lstlisting}\begin{itemize}\item The function \verb|f| is assumed to take an element of \verb|'a| as an argument.\item The function \verb|f| is written in \verb|'a|.\item \verb|f| is a function from \verb|'a| to \verb|'a| list.\item The size of the list is \verb|n|.
4.The definition of 'merkle_product' is not too hard to follow and understand, however, it is hard to maintain, and it is hard to use.The "lemma merkle_product" definition is clear, but it has assumptions, which implies that the user must know how to use them.In general, some formalisations are clearer than others, and some formalisations are more expressive than others.The Isabelle standard library has a number of definitions and lemmas that can be used in a formalisation. A formalisation can be built on top of those or extend them.\section{Conclusion}Isabelle is a programming language for building formal proofs about software systems. In this paper, we have introduced Isabelle/HOL, and some of the features of the language.The paper does not include many examples, and as such, it is probably not suitable for a beginner. However, the paper gives a good introduction, and is a good starting point.
7.(* We can make it better *)open merkle_interface_auxabbreviation (input) "'a + 'b \<times> 'c \<Rightarrow> 'c setset_base_F\<^sub>m \<equiv> \<lambda>'a + 'b \<times> 'cx. 'a + 'b \<times> 'c \<Rightarrow> ('b \<times> 'c) setsetr 'a + 'b \<times> 'cx \<bind> 'b \<times> 'c \<Rightarrow> 'b setfsts"abbreviation (input) "'a + 'b \<times> 'c \<Rightarrow> 'c setset_rec_F\<^sub>m \<equiv> \<lambda>'a + 'b \<times> 'cA. 'a + 'b \<times> 'c \<Rightarrow> ('b \<times> 'c) setsetr 'a + 'b \<times> 'cA \<bind> 'b \<times> 'c \<Rightarrow> 'c setsnds"abbreviation (input) "'a + 'b \<times> 'c \<Rightarrow> 'c setset_base_
7.The Isabelle formalization has a quality of 10.The SMT formalization has a quality of 7.*/:- module t13_2.:- use_module isabelle/util.:- use_module isabelle/smt.:- use_module(isabelle/util).:- use_module(isabelle/smt).:- public declaration(empty_scope).:- public declaration(empty_scope, name=list_R1, import=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1).:- public declaration(empty_scope, name=list_R1
7.What can be improved?The proof for list_R1_to_list_simps is not very nice. It makes the formalization quite long and more difficult to understand.The snippet is written in a somewhat unorthodox way. It would be better to use a definition which is easier to read. For example:lemma list_R1_to_list_simps [simp]:  "'a list_R1 \<Rightarrow> 'a listlist_R1_to_list (unit + 'a \<times> 'a list_R1 \<Rightarrow> 'a list_R1list_R1 (unit \<Rightarrow> unit + 'a \<times> 'a list_R1Inl ())) = []"  "'b list_R1 \<Rightarrow> 'b listlist_R1_to_list (unit + 'b \<times> 'b list_R1 \<Rightarrow> 'b list_R1list_R1 ('b \<times> 'b list_R1 \<Rightarrow> unit + 'b \<times> 'b list_R1Inr ('bx, 'b list_R1xs))) = '
7.\end{code}In Isabelle, a formalization can be partially trusted, it can be good, or bad, and it can be trusted fully. These three criteria are independent from each other.Both trust and goodness are a matter of taste and depend on the context of use.\section{Background}I have created a small package that collects, categorizes, and evaluates a number of Isabelle quality indicators. It is available at https://github.com/mab/isabelle-quality-evaluator. It is based on Isabelle 2016 and is not compatible with earlier versions.The package contains a number of examples. The one above is taken from the examples. Some of them are commented out.The `trust` value is computed from the other two, as explained in the README file.\section{Acknowledgements}I would like to thank Eelco Visser, Jürgen Roth, and Nico Janssens for their help with this package.\section{Disclaimer}This package is not intended to be used in production
6.\subsection{What about the formalization quality?}Isabelle's formalizations can be used in many contexts. We want them to be as usable as possible.If a formalization is incomprehensible, it is not very useful.It should also be \textbf{maintainable}, so that in case a lemma needs to be updated or changed, it can be done with little effort.\subsubsection{Maintainability}Isabelle's tooling makes it easy to maintain formalizations. The \textbf{Change History} feature allows one to keep track of the evolution of a formalization and to revert to earlier versions in the event that a lemma needs to be changed.The \textbf{Define} command can be used to add new definitions or lemmas to a formalization, thereby making it easier to keep track of the different parts of the formalization.In addition, the Isabelle Proof Assistant allows one to use the \textbf{claim} command to enclose a proof, which will then be automatically numbered as a lemma.\subsubsection{Understandability}Isabelle's proof
5. This is not bad, but it could definitely be improved.For a typical Isabelle/HOL formalization of a program, there will be many definitions, lemmas, and theorems. In fact, the user might not even want to look at this Isabelle/HOL formalization, but rather at a \LaTeX{} presentation of the proof tree. When we get to this stage, our Isabelle/HOL formalization is no longer useful. Instead of looking at the Isabelle/HOL formalization, we want to look at a presentation of it.There are many tools to generate \LaTeX{} presentations of Isabelle/HOL proofs. Here is an example using \LaTeX{}'s TikZ/PGF package and its pstricks library:\begin{verbatim}(* generating the .tex file *)with_tikZ_pkg pgf;import pgf.graphics_typesetting;begin(* writing the \input command *)\input{../_proof_tree_main/main_proof_tree.tex}(* filling the document *)\makeatletter\def\i
5.In the real world, you will probably have many definitions and lemmas.For example, I have a function that checks whether a certain property is satisfied for a certain structure.The property is specified as a big logical formula, and is true for some specific values of the structure's attributes.In the Isabelle formalization, this property is specified in a formula using the @{text "all}" operator.There are a lot of these properties and they are quite complex.The code that generates them is not trivial either.So it makes sense to abstract this away into a reusable function.However, defining and proving this function is not trivial either.The following code shows a way to do this:####################################################### Example######################################################definition (name := "all_prop") :: "(('a \<times> 'b) list) \<Rightarrow> bool" where  "all_prop = (\<lambda>(l: 'a list) \<equiv> all P l)"definition (name := "Prop_all") :: "(('a \<times> 'b) list) \<Rightarrow>
4.When assessing the quality of a formalization, we want to be able to make a distinction between a formalization that is “bad”, one that is “average”, and one that is “good”.The two latter quality classes need not be mutually exclusive.\subsection{The Isabelle quality scale}Isabelle provides a number of quality attributes that indicate the level of correctness and the level of readability of a formalization.\begin{description}\item[\emph{Isabelle/Isar}]The \emph{Isabelle/Isar} attribute gives the user an immediate indication of the quality of a formalization.\begin{itemize}\item A \emph{Isabelle/Isar} level of 0 means that the formalization is correct (its proof is correct).\item A \emph{Isabelle/Isar} level of 1 means that the formalization is correct (its proof is correct, and its proof is easy to follow).\item A \emph{Isabelle/Isar} level of 2 means that the formalization is correct (its proof is correct, and
3. It is understandable and easy to use, but the definitions are not as clear as they could be.Our next example is a formalization of the \emph{Zeno} paradox.\begin{snippet}lemma "X\<^bsub>0\<^esub> \<turnstile> \<langle>X\<^bsub>0\<^esub>, X\<^bsub>1\<^esub> \<rightarrow> X\<^bsub>2\<^esub> \<Rightarrow> X\<^bsub>0\<^esub> \<turnstile> \<langle>X\<^bsub>0\<^esub>, \<langle>X\<^bsub>1\<^esub>, X\<^bsub>2\<^esub> \<rightarrow> X\<^bsub>3\<^esub> \<Rightarrow> X\<^bsub>0\<^esub> \<turnstile> \<langle>X\<^bsub>0\<^esub>, \<langle>X\<^bsub>1\<^esub>, \<langle>X\<^bsub>2\<^esub>, X\<^bsub>3\<^esub> \<rightarrow> X\<^bsub>4\<^esub> \<
5.\section{Maintainability}Isabelle's Ltac and proof environment is very expressive. However, it can be very difficult to find the right Ltac commands and their order.\section{Understandability}Taking into account the fact that Isabelle can be used as a programming language, it is always important to keep in mind the programming paradigm of the language.For example, the following is a simple proof in which a statement is proven using \texttt{is\_between}:\begin{lstlisting}  check_int :: "nat \<Rightarrow> nat \<Rightarrow> bool" where  check_int x y = is_between x y \<or> is_between y x\end{lstlisting}This proof is valid and correct. However, one should consider that the programmer is a mathematician and not a computer scientist.As a mathematician, I would rather write a \texttt{function} instead of a \texttt{functor} as it is more familiar. Also, it is not very clear that the expression \texttt{is\_between x y} is a
4. The author did a good job on proving the theorem but the lack of definitions is a bit of a problem.In this example, we can see that the quality of this Isabelle proof ranges from 1 to 10. A proof that is a 10 has all the qualities described above.Open Questions:1) Is there a way to tell Isabelle to take care of certain problems, such as the ones in the above example?2) Is there a way to measure the quality of an Isabelle proof in a more objective way?
4.Now, let us try to assess the quality.First, a Formalization is correct if the Isabelle proof is correct. So we can be assured of the correctness of this Formalization.Second, the definitions are understandable. To me, they are clear and easy to read.Third, this Formalization is easily maintainable. A new Isabelle proof is not needed, as it can be extended to cover new definitions and lemmas.Fourth, this Formalization is easy to use. When we want to prove the same statement, we only need to write a few lines of code, rather than writing a large proof.To me, this Formalization has a total quality of 8.Thus, it is good enough for my own needs. I can be sure that this Formalization is correct and that it is easily maintainable and usable.\section{A Formalization with a High Quality}Let us make a Formalization with a high quality.First, we will define the abstraction of a hash function, whose definition is more general than what we want to formalize
9.However, I would probably improve the following:\begin{code}lemma list_R1_set_defs:  "('a list_R1x :: 'a list_R1 setA) \<Longrightarrow> 'a list_R1 set?"  [unfolded blinding_of_F_def, unfolded list_R1.def list_R1_def, rule list_R1.refl, rule list_R1_def, rule blinding_of_F_def, rule list_R1_refl]  by blast\end{code}This is a list of definitions and lemmas, which is actually \strong{not} the way to present a proof to the reader. Let us take the following snippet instead:\begin{code}lemma list_R1_set_defs [intro] (is "('a list_R1x :: 'a list_R1 setA) \<Longrightarrow> 'a list_R1 set") [unfolded blinding_of_F_def, unfolded list_R1.def list_R1
4. It works, is correct, but the proof that it works is too long, and it is quite difficult to follow the definitions.Our goal in formalizing Isabelle is to reach a 10/10.The criteria used to assess quality are the following:\begin{itemize}\item understandability\item maintainability\item ease of use\end{itemize}The criteria are not ranked or given different weights.\subsection{Understandability}\label{sec:def:understandability}The goal of understandability is to maximize the degree of understanding of the formalization by the reader. In other words, the reader should be able to understand everything in the formalization, as well as the algorithmic solutions implemented in the formalization.A lack of understanding is often caused by a lack of documentation and lack of explanation of how the formalization works.Understandability is measured with respect to the following questions:\begin{itemize}\item Does the formalization clearly explain the purpose of the formalization?\item Does the formalization contain a clear explanation of the algorithm implemented?\item Is
5. If I am asked to do more work in this formalization I would most likely do it in another formalization.Because the Isabelle formalization tool is \textbf{interactive} and the user can type commands, it is difficult to do systematic checks.That is why we have the Isabelle library \cite{DBLP:conf/isabelle/Carlsson00}.It is a collection of systematic checks that perform check on Isabelle formalizations.\subsubsection{Lightweight Formal Verification}To verify an Isabelle formalization, one can do the following:\begin{itemize}\item Rely on the \textbf{checking library} which performs check in the Isabelle kernel.\item Do formal proofs using the Isabelle \textbf{proof assistant}.\item Do \textbf{model checking} to do model checking.\item Do formal \textbf{analysis} to find bugs, to do formal code analysis, or to reason about the performance of a program.\item Do \textbf{automated theorem proving} to do automated theorem proving.\item Do \textbf{model generation} to generate
3.It is completely understandable. There are no confusing definitions. The lemmas are well named and self-contained. However, it could be improved.The most obvious problem is the lack of a definition of merge_R1. In Isabelle, we can define functions that take a type and return a type. So we could definemerge_R1 :: "type'a\<^sub>m list_R1\<^sub>m merge"and then use this function in the proof. However, we would lose the ability to see the types of the functions in the argument positions, which are very important for understanding the proof. Instead, we would have to use typemerge_R1 :: "('a \<Rightarrow> 'b) list_R1\<^sub>m merge"which is more cumbersome and a little less clear.It is possible to introduce definitions in Isabelle that refer to variables rather than types, so we could writetype R1 = "('a \<Rightarrow> 'b) list_R1\<^sub>m merge"and then definemerge_R1 :: "R1"Then we could
5.The definition of \texttt{merge_R1} is correct, and the proof of \texttt{merge_on_R1} is also correct, although its first line is missing an \texttt{assumes}.Even though the code is valid, the definitions are incompletely specified. The definition of \texttt{merge_R1} is missing a \texttt{let} statement at the beginning, and \texttt{merge_R1} itself has a number of missing \texttt{assumes}. The definitions of \texttt{merge_on_R1} and \texttt{merge_R1} are also missing \texttt{assumes} and \texttt{lems}.The proof of \texttt{merge_on_R1} is also incompletely specified. The first line of the proof does not specify an \texttt{assumes} statement, and the \texttt{assumes} and \texttt{lem} statements are missing \texttt{match} statements.I have used Isabelle/HOL's \texttt{case_of_simps} tactic to do this proof checking, which can be found in the library \texttt{
10.It should be clear how to use it, as it is written by a human.It is concise, easy to read, and easy to understand.It should also be easy to maintain, as a proof is also a program.Its length is reasonable and it does not grow too much if more lemmas and definitions are added.In conclusion, this example can be used for teaching.******************************************************************************/open import "/home/yassin/development/proof_ir/lib/Isabelle2018/Prelude"open import "/home/yassin/development/proof_ir/lib/Isabelle2018/Isabelle"@preamble(*  ********************************************************************** *)(*  Proofs                                                                 *)(*  ********************************************************************** *)subsection \<open>The Isabelle Proof API\<close>(*  ********************************************************************** *)(*  Proofs                                                                 *)(*  ********************************************************************** *)theorem "a \<in> A
5. The structure is more or less correct, but there are some problems.First of all, it is hard to read, as the notation is quite strange, the structure is not always clear, and the use of quotation is not intuitive.Secondly, some parts are not correct.A comment (at line 10) refers to the index-type `set_base_F` (which is not even defined!).The definition of the function `merge_on` is incomplete.The last definition is not correct. `setunit` is not defined and neither is `setset_rec_F`.We would like to create a system that could automatically give a quality score to formalizations.\end{document}\end{code}
6.\paragraph{Quality Assessment}In this section, we will introduce a metric for assessing the quality of formalizations.\begin{definition}[Quality of a Formalization]Let $F$ be a formalization and $t$ be a type.We define the \textbf{quality} of the formalization $F$ with respect to the type $t$ as\[\mathrm{qual}(F,t) = \max_{X \in \mathcal{P}(t)} \min_{(\alpha, \beta) \in X} |\beta|\]where $\mathcal{P}(t)$ is the power set of $t$.\end{definition}In other words, the quality is the maximum size of a type set that can be inferred from $F$ and the minimum size of the type set that can be inferred from $F$ under the assumption that all variables in the type set are bound by the formalization $F$.\begin{example}Let $t = \{a,b\}$ and $F$ be the formalization above.The quality of $F$ with respect to
2.The Isabelle specification language is designed to create formalizations that are easy to understand and maintain. These properties are not guaranteed by formalizations created with this language, but we can make them likely.The first step is to make sure that every step in the formalization is defined in an unambiguous way. Isabelle allows us to define symbols by giving their meaning.In our example, we defined the symbol `bool?bo` by giving its meaning. The meaning of this symbol is given by the lemma `bool?bo`, which is defined by giving the meaning of its arguments.Unfortunately, the definition of `bool?bo` is ambiguous. There are two symbols with that name in the Isabelle language. To avoid this problem, we have to tell Isabelle to use one of them. The symbol `bool?bo` is defined by the command `FUNC bool?bo`, which can be used to define a symbol with the given meaning.Now we define our function and we will be able to use the symbol `bool?bo` without ambiguity.This is the definition of `bool?bo`:\begin{code}FUNC bool?
4.* Improving the qualityA formalization can be improved by adding comments, using the short cuts ``qed``, and by grouping statements in a more readable way.In particular, adding comments can improve the quality of a formalization by improving its readability:  "  See if we can prove that by blast+.  We'll need some lemmas.    Let us first introduce some definitions.  We'll use a lemma:   lemma merkle_list_R1 [locale_witness]:    assumes "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> 'a option) \<Rightarrow> bool"    shows "('a list_R1 \<Rightarrow> 'b list_R1) \<Rightarrow> ('a list_R1 \<Rightarrow> 'a list_R1 \<Rightarrow> bool) \<Rightarrow> ('a list_R1 \<Rightarrow> 'a list_R1 \<Rightarrow> 'a list_R1 option) \<Rightarrow
4, it is somewhat clear, understandable, maintainable, and easy to use.That being said, it is still not perfect:The proof of `merge_R1_cong` is too long and not easily understood.The definition `merge_R1_parametric` is not very readable.In `merge_R1.induct`, the type `optionmerge_R1 'a list_R1x 'a list_R1y` is defined, but not used, and it is not clear what it means.The definition `merge_F_def` is not used or defined anywhere in this snippet.In `merge_cases`, the use of `merge_F_cong` requires a definition of `merge_F_def`.In `merge_cases`, the definition of `merge_F_def` is not used in the proof.In `merge_cases`, the definition `lifting_syntax` is not used.`merge_R1.induct` defines `optionmerge_R1`, but does not use it, and it is not clear what it means.The proof of `
2.However, the above snippet suffers from the following problems:\begin{itemize}\item It is not self-contained: A reader has to read the context to know how to interpret it.\item The snippet's proofs are hard to understand because they are nested several times and hard to follow. This is especially problematic if the proof is not that short.\item The proofs are not well-suited for automated verification: The proof is not easy to extract, as the definitions, lemmas and proofs are interleaved.\item The proof's style is not easily understandable: It relies on the notations of the [curry] library.\item The proof is not easy to maintain: The reasoning is encoded in a context and changing this context means rewriting most of the proofs.\end{itemize}As a solution to these problems, Isabelle provides several different techniques that are used for different purposes.In this section, I will introduce some of these techniques, and show some examples.\subsection{Using the \emph{Most} Formalization Technique}The \emph{Most}
4.One could potentially improve this by replacing the definition of blinding_of_hash with something like this:lemma blinding_of_hash_R1:  "\<lbrakk> \<And>'ax 'ay. 'a \<Rightarrow> 'a \<Rightarrow> boolbo 'ax 'ay \<longrightarrow> 'a \<Rightarrow> 'a \<Rightarrow> boolbo' 'ax 'ay \<rbrakk> \<Longrightarrow>   ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> 'a list \<Rightarrow> boolblinding_of_list 'a \<Rightarrow> 'a \<Rightarrow> boolbo 'a listx 'a listy \<longrightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> 'a list \<Rightarrow> boolblinding_of_list 'a \<Rightarrow> 'a \<Rightarrow> boolbo' 'a listx 'a listy"  by (transfer) (blast intro: list_R1.rel_mono_strong)lemmas blinding_of_list_hash_R1 = blinding_of_
9.Therefore we can say that the formalization is correct.\subsection{Formalizing with Isabelle/HOL}Isabelle is a theorem prover.The user can write (small) definitions, theorems, lemmas, and proofs.The Isabelle prover tries to derive new theorems and lemmas from these definitions, and also proofs from these theorems and lemmas.Isabelle can be used to formally prove (among other things) the correctness of programs.The programs are formalized using the SMT solver Z3.To check the correctness of the program, we need to formally prove the existence of an algorithm that is correct.In Isabelle, it is always possible to formally prove the correctness of a program.However, it can be a bit tricky to formalize a program, and we will learn to do that in this tutorial.\subsection{The Main Program}The formalization of the program is given as a formal system in the file \texttt{main.hs}.This file contains the following five programs:\begin{lstlisting}
10.Snippets can be written by hand, or they can be generated automatically from the Isabelle API.Generating from the API is somewhat more involved and will not be described here.Writing them by hand is easy. You just need to define a text file (usually `.isb` files) that contains your definition. For example, if you want to write the definition of the type\[\mathsf{StateType} :: "typedef \<Rightarrow> 'a \<Rightarrow> 'b"\]Then you would write the following text file:\begin{lstlisting}(* Note that the next line must be indented. *)type \<Rightarrow> 'a \<Rightarrow> 'b\<equiv> "{'a} \<Rightarrow> 'b"type_synonym StateType :: "typedef \<Rightarrow> 'a \<Rightarrow> 'b"abbreviation (input) ST_hash :: "StateType \<Rightarrow> (typedef \<Rightarrow> 'a \<Rightarrow> 'b) hash"  where "StateType \<Rightarrow> 'a \<Rightarrow> 'bhash_fun
5.However, one could go further and refactor the definition of blinding_of_fun_mono to the lemma below.lemmas blinding_of_fun_mono' = fun.rel_mono'lemma blinding_of_fun_hash:  assumes "'a \<Rightarrow> 'a \<Rightarrow> boolbo \<le> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('b \<Rightarrow> 'b \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> boolvimage2p 'a \<Rightarrow> 'brh 'a \<Rightarrow> 'brh (=)"  shows "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('c \<Rightarrow> 'a) \<Rightarrow> ('c \<Rightarrow> 'a) \<Rightarrow> boolblinding_of_fun 'a \<Rightarrow> 'a \<Rightarrow> boolbo \<le> (('c \<Rightarrow> 'a) \<Rightarrow> 'c \<Rightarrow> 'b) \<Rightarrow> (('c \<Rightarrow> 'a) \<Rightarrow> 'c \<Rightarrow> 'b
6.Why are definitions missing? Why are some proofs so long? Why is the code not easily readable?In general, when Isabelle starts producing large proofs and unreadable definitions, this is a sign that the formalization is not well-designed.In Isabelle, an action that can be written in an unreadable way can also be written in a nice way. Unfortunately, the latter is not as natural.Another reason is that Isabelle is not just a proof assistant. It is a general-purpose programming language. This means that Isabelle can be used to write code that is hard to understand.Sometimes, Isabelle itself is not to blame. The definition of the object being formalized may be too complex, which may lead to long proofs and confusing definitions.A simple rule of thumb is that if you are not sure if a definition or proof can be understood by anyone, it is most likely a bad definition or proof.Let us look at some ways to improve a proof, or a definition.\subsection{Improving Formalizations}\begin{enumerate}\item \textbf{Easier to read definitions}
2.The Isabelle formalization of the above snippet was verified by formalverification.org, which is a service to verify Isabelle code.As you can see, the Isabelle code contains an external source code file,which is a program written in OCaml, and some HOL code.It is not possible to share the Isabelle source file, butthe program and the OCaml source file can be shared,and I have done so in the following repository\cite{basit2014a}.The Isabelle code can be verified in the same way as the OCaml source file.The formalverification.org service is an open-source project, which allows you to use its free services. It is a good service for verifying Isabelle code.\section{Future work}The program and the Isabelle code are available on GitHub\cite{basit2014a}.The Isabelle code can be verified in the same way as the OCaml source file.The formalverification.org service is an open-source project, which allows you to use its free services.It is a good
2.In order to determine the quality of a formalization, I would first rate it on the number of dependencies used (e.g., @{cite "depend"}).I would then look at the dependencies between the assumptions and the hypotheses.I would also check if the formalization is "wrapped" in a theorem, that is, if it is used in a proof of another theorem.In the example above, it is not wrapped and the proof is not too long (but it could be a lot shorter).Finally, I would also consider the language used in the formalization. For example, in the example above, I would have preferredproof -  interpret a: merge_on 'b\<^sub>m set'b\<^sub>m setA 'b\<^sub>m \<Rightarrow> 'a'b\<^sub>m \<Rightarrow> 'arh 'b\<^sub>m \<Rightarrow> 'b\<^sub>m \<Rightarrow> bool'b\<^sub>m \<Rightarrow> 'b\<^sub>m \<Rightarrow> boolbo 'b\<^sub>m \<Rightarrow> 'b\<^sub>m \<Rightarrow> 'b\<^
4 or a 5.While writing the Isabelle proof, we of course had to take care about the syntax and the layout. The writing process was very iterative, which means that the proof we ended up with was not the first or the second version.It is easy to write a proof and then later to come back to it and improve it. A clean proof is always easy to read, which makes it easy to write further proofs that build on it.This is a very good property of the Isabelle proof assistant and its ``definition-theorem-proof'' cycle. It is easy to check the proofs and then to write a new proof that builds on the old one.I know that some proofs in Isabelle are very long and hard to read. I think that is a problem with how the proofs were written. It can happen that the proof is written in a way that the reader has to guess what the goal of the proof is. The first proof in the Isabelle book is an example of such a proof.However, in general, I would say that the writing quality of an Isabelle proof is very high.\subsection{What are the advantages and disadvantages of using Isabel
6.(*   - we could improve the definitions of merge_fun_def and the    alt_defs for is_none_def and is_some_def  - we could try and make it more readable  - we could use a different theorem prover (CVC4, Coq)*)lemma is_some_alt_def: "is_some_def = ('a \<Rightarrow> 'b option) => boolOption.is_some 'a option \<longleftrightarrow> (case 'a option of Some \<Rightarrow> boolTrue | None \<Rightarrow> boolFalse)"  by (auto simp add: Option.is_some_def split: option.splits)lemma is_none_alt_def: "is_none_def = ('a \<Rightarrow> 'b option) => boolOption.is_none 'a option \<longleftrightarrow> (case 'a option of None \<Rightarrow> boolTrue | Some \<Rightarrow> boolFalse)"  by (auto simp add: Option.is_none_def split: option.splits)lemma is_some_def [transfer
9. The only problem is that I need to understand the proof that the "transfer_prover" function is correct.\section{The problem}Formalizations of Isabelle tend to be quite long and verbose. They are not always clear and presenting the proof of a lemma can be a challenge.This is not a problem with Isabelle as such but rather a problem with how we choose to use Isabelle.For example, the following snippet would have a quality of 8:\begin{code}assume m: "('a \<Rightarrow> 'b \<Rightarrow> boolA) 'a \<Rightarrow> 'a \<Rightarrow> 'a option \<Rightarrow> 'b option \<Rightarrow> boolrel_option 'a \<Rightarrow> 'b \<Rightarrow> boolC)"    and f: "((=) ===> 'a \<Rightarrow> 'b \<Rightarrow> boolA) 'c \<Rightarrow> 'af 'c \<Rightarrow> 'bf" and g: "((=) ===> 'a \<Rightarrow> 'b \<Rightarrow> boolB) 'c \<Rightarrow> 'ag 'c \<Rightarrow> 'bg"  note [transfer_
3:\begin{itemize}\item The author is not very consistent. In the definition of `optionSome` he does not use the type `optionm`.\item The `optionC` proof is completely irrelevant to the case at hand.\item The `bool?` proof is not very clear.\end{itemize}\section{Further Reading}If you would like to improve your formalizations, you may want to read the following text:\begin{itemize}\item [Guide to Good Isabelle/HOL Proofs](http://caml.inria.fr/pub/docs/manual-release/general/doc/guide/docbook.pdf)\item [Isabelle/HOL Introduction and User Guide](http://isabelle.in.tum.de/doc/ Isabelle/HOL-Book.pdf)\item [Isabelle/HOL Reference Manual](http://isabelle.in.tum.de/doc/ Isabelle/HOL-Manual.pdf)\item [Pragmatics of Isabelle/HOL](http://isabelle
5 or maybe 6.Formalizing Isabelle/HOL software is a very time-consuming task. It is important to avoid re-writing definitions, theorems, and lemmas that are already in the base library.Moreover, the documentation and comments in the Isabelle/HOL library are very extensive. A lot of effort has been spent to make the library as clear as possible. The documentation and comments are often the best place to start when assessing quality.\section{A Tool to Check the Quality of Isabelle Formalizations}\label{sec:quali-check}Formalizing is hard work. The level of abstraction necessary to make an Isabelle/HOL proof easy to follow is often too high. This causes many of the proofs to be much longer than they should be.I have created an Isabelle checker to help with this. It can be used to check for the following:\begin{itemize}\item Too many definitions\item Too many theorems\item Overly long proofs\item Mismatches between theorems and definitions\item Tautologies\
10.Isabelle should give a score for the quality of the formalization to allow users to assess their own work.\end{document}\end{code}Comment: Thanks for posting this question.  I have been searching for the same thing for my isabelle formalization (http://users.cecs.anu.edu.au/~r221914/main/Papers/2014/ICTAC2014.pdf), but could not find any answer.Comment: I found a few results by searching `isabelle quality`, but I'm not sure if those are relevant.Comment: @stivish This is probably a dup of https://stackoverflow.com/questions/11342893/is-there-an-isabelle-quality-scoreAnswer: This is not an answer to your question, but a general comment about quality (which is related to the question):The quality of the source code is heavily dependent on its readability. It is possible to achieve maximum quality in formalization by using advanced features, like type-level programming, homotopy types
5.I am looking for a way to formalize my code for this and similar snippets so that the quality is increased. I was looking into the [criterion](http://www.cl.cam.ac.uk/~rja14/Papers/criterion.pdf) but this formalization is not working for me. I am pretty new to Isabelle, so any advice is welcome.Answer: The fact that an Isabelle formalization is correct does not mean that it is the best one. In the example you have given, the definition of map_rose_tree_F can be rewritten using the higher-order datatype mechanism, which is the easiest way to formalize it in Isabelle. It would look like this:\begin{code}definition (input) map_rose_tree_F' :: "'a \<times> 'm \<Rightarrow> 'a"  where "map_rose_tree_F' \<equiv> (\<lambda> (a, ma) . (a, ma map (tree ma)))"\end{code}This definition is more readable, uses less syntax, and is much more efficient.However
9. The developer didn't go overboard, and one could add more definitions and lemmas if needed.However, in my opinion, this is not the best Isabelle formalization, which would be something like this:lemma hash_rt_F\<^m>:  fixes f :: "type'a\<^m rose_tree_F\<^m"  fixes g :: "type'b\<^m rose_tree_F\<^m"  assumes "\<forall>s \<in> (sorts_of f) . \<forall>t \<in> (sorts_of g) . 0 \<le> f ! s \<le> size f - 1 \<and> 0 \<le> g ! t \<le> size g - 1 \<Rightarrow>     (f ! s, g ! t) \<notin> tup_pair rose_tree_F\<^m \<and> (f ! s, g ! t) \<notin> tup_pair rose_tree_F\<^m"  shows "hash_rt_F\<^m f g \<le> hash_rt_F\<^m (\<lambda>x. (f x, g x
6. In this case, we have an obvious mistake:`transfer` is used where `hash_rt_tree'` is expected. This is a simple typo.We could give a formal proof that `hash_rt_tree'` is `hash_rt_tree`, which will be correct, but it will be hard to follow.One could also say, that it is a 6 on the \textit{simplicity} scale.Furthermore, it is likely that if this formalization was part of a larger proof, `hash_rt_tree'` would be changed to `hash_rt_tree`, as it is just a typo.So what would be a better formalization?At a glance, the following formalization is better:by(simp add: hash_rt_F\<^sub>m_def fun_eq_iff hash_map_blindable_simp)primrec (transfer) hash_rt_tree  :: "((type'a\<^sub>h, type'a\<^sub>h) rose_tree\<^sub>m, type'a\<^sub>h rose_tree
3.The proof is well-typed, but confusing: I am not sure what exactly it proves, and that I have to do something to get the third clause to work.I would find the proofs to be more readable if they were explicit, e.g. using \code{\<le>*} or \code{\<le_if>*} to define a type class with an appropriate signature and then use the class to construct a proof, like in\code{definition hash_tree' (T::(type'a\<^sub>m, type'a\<^sub>h) hash)  (keys::(type'a\<^sub>m, type'a\<^sub>h) keys) (h::(type'a\<^sub>m, type'a\<^sub>h) hash) (c::(type'a\<^sub>m, type'a\<^sub>h) rose_tree\<^sub>m) (c1::(type'a\<^sub>m, type'a\<^sub>h) rose_tree\<^sub>m)  (c2::(type'a\<^sub>m, type'a\<^sub>h)
6.To improve the quality, we need to understand the goal of the proof, the intent of the definition, and the implementation of the theorem.To that end, we can use Isabelle's automated theorem proving tools.\section{How to use Isabelle}The following interactive tutorial explains how to use Isabelle 2014 for proofs in Coq.The tutorial requires the installation of the Coq plugin, which is also explained in the tutorial.\section{How to use Isabelle}The following tutorial explains how to use Isabelle 2014 for proofs in Coq.The tutorial requires the installation of the Coq plugin, which is also explained in the tutorial.<h3>How to use Isabelle</h3><a href="http://isabelle.in.tum.de/tutorials/how_to_use_Isabelle">http://isabelle.in.tum.de/tutorials/how_to_use_Isabelle</a><h3>Coq plugin</h3>If you want to use Coq,
4.Isabelle will not tell us what is wrong. We have to figure that out ourselves. However, in the following list of examples, Isabelle does not tell us that something is wrong.#### Formalizations that fail to be correct* They contain undefined terms or undefined functions* They contain undefined lemmas and theorems* They contain undefined types#### Formalizations that fail to be understandable* The formalization is too long. See the very long definition of `BitVec`* The formalization is too verbose. See the definition of `Cof_bit`* The formalization is too difficult to follow. See the definition of `P01`#### Formalizations that fail to be maintainable* They contain repeated definitions of terms and functions* They contain repeated proofs* They contain repeated definitions of lemmas and theorems* They contain repeated definitions of types* They contain repeated references to theorems* They contain repeated references to definitions#### Formalizations that fail to be usable* They contain undefined references to theorems* They contain undefined references to definitions* They
5.We would like to give it a 7 or 8.The snippet is hard to understand and follow. \index{proof-sketch}The proof sketches are not very helpful.The proof has to be understood in its entirety and not only the proofs sketched.It is not easy to determine whether the proof sketches capture the proof of the lemma.One possible solution would be to write a little bit longer proofs sketches, and of course the proofs of the lemma.\index{proof_sketch_draft}However, this leads to a 10-page long lemma!\index{proof_sketch_draft}\begin{example}\index{lemma!blinding_of_rt_F\<^sub>m_mono_inductive}\begin{lstlisting}lemma blinding_of_rt_F\<^mono_mono_inductive:  "\<lbrakk> 'a \<Rightarrow> 'a \<Rightarrow> boolboa \<le> 'a \<Rightarrow> 'a \<Rightarrow> boolboa'; 'b \<Rightarrow> '
5, which is not bad at all.However, what if we want to debug it?We can use Isabelle's interactive mode. We can do a little more, we can easily add comments to the source code. We can see what works and what does not, we can pinpoint the problem, and we can fix it.In particular, if we would like to add or change the definition of the function assms in the proof, we need to take into account all the applications of it. We also need to redo all the theorems and lemmas that use it.This may require a lot of effort, and it may even be difficult to do completely.If we are lucky, we can do it without errors, but if not, we would have to track down errors, and this can be very frustrating.\textbf{So how can we improve this? \textit{What we would like to have is a tool that is able to do the following:}}\begin{itemize}\item It understands Isabelle's syntax\item It understands Isabelle's semantics\item It has a good understanding of Isabelle
7.\strong{What is good quality?}I would like to understand what makes a formalization good, and to hear about what people have tried and what worked, and what did not work.\strong{Does Isabelle have a formal definition for what makes a formalization good?}If not, I think it would be good to have a formal definition.What are the criteria for assessing the quality of an Isabelle formalization?Comment: As an addendum, a good formalization should not have to be understood. If it has to be understood, it's not good enough.Comment: 1. What is a good Isabelle formalization? This is a good question! 2. It is not clear to me if this is a question about Isabelle programming or Isabelle theorem proving. Please indicate which you are interested in.Comment: @kassamba I am interested in formal theorem proving. I will edit my question.Answer: Isabelle can give the following definitions:\begin{code}lemma blinding_of_rt_F_hash:  fixes k::int  fixes m::nat
2. It is unreadable, it is not very easily verifiable, and it is not very easy to maintain.There are different ways to improve the quality of an Isabelle formalization.The following are some ideas:\begin{enumerate}\item \textbf{Structure}:\begin{itemize}\item Use the `\textbf{structure}` tactic to divide your proof into different sections, where each section should define a single lemma.\item This is very useful for long proofs.\item A very common error is to create proofs that are too long and/or very difficult to follow.\item This is why Isabelle has a cut command (which is what `\textbf{structure}` actually does).\item Using a `structure` in Isabelle, is also equivalent to saying `introduce` in Coq.\end{itemize}\item \textbf{Elegance}:\begin{itemize}\item Make your definitions easy to understand by using `unfold` and `abbreviation` as much as possible.\item Don't use `assumption` too much.\item Don't use `assertion`
4.Let us now look at the proof of the same lemma using a slightly different formalization style:apply(rule predicate2I vimage2pI)+  apply(erule blinding_of_tree.induct)  apply(simp)  apply(erule blinding_of_rt_F\<^sub>m_hash[OF assms, THEN predicate2D_vimage2p, rotated 1])  apply(blast intro: vimage2pI)  doneabbreviation (input) set1_rt_F\<^sub>m :: "(type'a\<^sub>m, type'a\<^sub>h, type'b\<^sub>h, type'b\<^sub>m) rose_tree_F\<^sub>m \<Rightarrow> type'a\<^sub>m set" where  "('a\<^sub>m \<times> 'b\<^sub>h list, 'a\<^sub>h \<times> 'b\<^sub>m list) blindable\<^sub>m \<Rightarrow> ('a\<^sub>m \<times> 'b\<^sub>h list) setset1_
3.How can we assess the quality of a formalization, and how can we improve it?This is where \texttt{FixM} comes into play.We can simply examine all the proofs that are in the formalization, and mark as many as possible as having errors.Then we can try to fix the errors and assess the quality of the formalization again.If it is still 3, we can try again and again until it is 10.In order to improve the quality of a formalization, we can write and implement the missing definitions and lemmas.The formalization will still be correct, but it will become a little bit harder to understand.Alternatively, we can also add comments that help to understand the formalization.FixM also allows us to give feedback on a formalization:Whenever a user of a formalization wants to give feedback on the formalization, he can add a comment.The system will then create a new ticket for the formalization, and send the comment to the maintainers.The maintainers can then see all comments and decide if they want to implement them.\section{Why Formalize
2.There is still a lot of things that could be improved:\begin{itemize}\item The definition of `hash_blindable_def` is repeated. This can be avoided using `hash_blindable_def` from the `hash_blindable` module (or any other equivalent).\item The naming `blinding_of_on_tree` is confusing, as it makes it unclear that it is a lemma.\item The definition of `blinding_of_on_tree` is too terse. What it really does is `blinding_of_on` on an indexed tree. This should be made more explicit.\item The definition of `blinding_of_on` is too terse. What it really does is `blinding_of_on` on a set of values. This should be made more explicit.\item The definition of `hash_tree` is too terse. What it really does is `hash_tree` on a set of values. This should be made more explicit.\item The definition of `rose_tree` is too terse. What it really does is `rose_tree` on
7. It is not a 10 because there are unclear definitions, and it is not a 0 because it is perfectly correct.Assuming we want to refactor this proof, we can easily begin by making the definition of the function `bo' more understandable and easier to use. We can also use the Isabelle/HOL command `rewrite' to prove it.\begin{code}  3 by(rule blinding_of_tree_hash)\end{code}Even without knowing the definition of `hash`, we can see that the proof is correct.\begin{code}  1 by (rule blinding_of_tree_hash)\end{code}Although we can see that the proof works, this is a 7.\begin{code}  by(rule blinding_of_tree_hash)\end{code}Once again, we can see that the proof is correct, but we do not understand the definition of `bo' so we give it a 7.\begin{code}  by rewrite bo_def\end{code}
6.\end{exa}\subsection{Two-way relationship between formalizations and Isabelle/HOL}Isabelle/HOL is a theorem prover that is powerful and flexible enough to cover a wide range of application domains. However, for a specific application domain, the size of Isabelle/HOL can grow to unmanageable proportions. In such a situation, formalizing a portion of a domain can be helpful. Even in cases where one has a good understanding of a domain and one can formalize it with only a few pages of Isabelle/HOL, one may still prefer to formalize it in Isabelle/HOL and then generate a short formalization.\begin{exa}\begin{table}[htb]\begin{tabular}{|l|l|}\hline\textbf{Snippet} & \textbf{Formalization} \\\hline\begin{lstlisting}Inductive dom_tree_int (I: int) : Type :=| Root : dom_tree_int I| Leaf : int -> dom_tree_int I.\end{
1 or 2.It is not too hard to understand and is not too hard to maintain.The proof is not too long and it is not hard to follow.It is easy to use as it can be copied and pasted into Isabelle.However, it does not follow good coding conventions.It is not easy to read as it is not in a Pythonic style.The proof is not documented, it is not self-contained, and it is not well-structured.There is no code that displays this proof.It is not easy to write other proof conditions.In Isabelle, the author wrote    (rule blinding_of_on)      apply (first blinding_of_on)      donewhich led to the above code. Isabelle automatically inserts the proof of the lemma blinding_of_on.But this code could have been shortened to    (rule blinding_of_on)      doneThis change is rather unintuitive, but the proof is much shorter and more elegant.Here is another example, from a different, more advanced proof:      {
6.It is understandable and maintainable, but not easy to use.Let us take the following snippet as an example:  "forall (P: 'a Prop), 'a (x, y) \<in> rose_tree\<^sub>m \<Longrightarrow> P x \<Longrightarrow> P y \<Longrightarrow> rose_tree\<^sub>mx \<in> rose_tree\<^sub>m set?A P"It is understandable, but not maintainable. We do not have any other examples in the Isabelle formalization to draw inspiration from.The proof of this lemma is correct, but not very easy to read.\medskipLet us take the following snippet as an example:lemma "!x. 'a (x, y) \<in> rose_tree\<^sub>m \<Longrightarrow> P x \<Longrightarrow> P y \<Longrightarrow> rose_tree\<^sub>mx \<in> rose_tree\<^sub>m set?A P"  by (induct P) (simp add: rose_tree_def)lemma "\<forall>x. 'a (x, y) \<in>
1 or 2.However, this is not always the case. It is possible to make a formalization which is correct, but which is hard to understand or maintain. For example, consider the following code:lemma blinding_of_tree_mono:  "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> boolbo \<le> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> boolbo"  by (auto intro: blinding_of_tree.induct)In this case, the lemma will be correct, but it will be very hard to understand and maintain. We may think that since the lemma is correct, we should use it. However, we have to think of the purpose of the lemma: we are trying
7. It could be improved by fixing the blindable overloads, as well as the definition of setset3_rt_F\<^sub>m.Let us now look at a formalization that is harder to read and that has more problems:lemma merge_rt_F\<^sub>m_cong [fundef_cong]:  assumes "\<And>'aa 'ab. \<lbrakk> 'aa \<in> ('a \<times> 'b list, 'c \<times> 'd list) blindable\<^sub>m; 'ab \<in> ('a \<times> 'b list, 'c \<times> 'd list) blindable\<^sub>m \<Rightarrow> 'a setset1_rt_F\<^sub>m ('a \<times> 'b list, 'c \<times> 'd list) blindable\<^sub>mx \<rbrakk> \<Longrightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a optionma 'aa 'ab = 'a \<Rightarrow> 'a \<Rightarrow> 'a optionma' 'aa 'ab"    and "\<And>'ba 'bb. \<lbrakk> 'ba \<in> ('a
4.\end{blockquote}Comment: I think this is actually on the high end of what people would consider acceptable.  There's a bit of inlining happening here, and some assumptions about `merge_RT_F_M_def` being defined, but the overall structure of this is pretty good.  This would certainly be a better formalization than most people would achieve.Comment: The thing that would improve it is to be able to use the `simp` tactics to inline the `merge_rt_F_m_def` assumption.  `simp` will do all of the work of going through the rules and patching in the right arguments and the assumption would be eliminated altogether.  Another thing that could be done is to replace the `simpl_all` tactic with `simpl`.  `simpl_all` is useful for generalizing results and reducing clutter, but it's not necessary for this particular proof.
5.The Isabelle documentation tries to describe the common approaches to producing good formalizations, but it would be nice to have more specific instructions.(A code snippet is in Isabelle syntax, not in a programming language like Haskell or OCaml.)Comment: Yes, I think this would be a good idea. I tried to document the subject of correctness, but it is hard to document all the things you need to do for this.Answer: I would say that the quality of a formalization depends a lot on the context, and that the state of the art is to document everything you can think of.One can think of several general approaches:\begin{itemize}\item \em{High-level document} describing the \em{goal} of the formalization and how to use it. The goal is to give the user the big picture and make him/her understand the relations between the formalization, the underlying concepts, and the "world".\item \em{High-level implementation} document containing all the implementation details and relevant proofs.\item \em{Low-level implementation} document containing all the implementation details and relevant proofs.\item
5.\begin{itemize}\item The formalization is easy to read but not quite clear.\item Some parts of the formalization are redundant, for instance, we could have just written merge_on 'a setA 'a \<Rightarrow> 'b 'a \<Rightarrow> 'bh 'a \<Rightarrow> 'a \<Rightarrow> bool instead of the above.\item A more experienced Isabelle user may find it easier to write `bool?thesis` instead of `show bool?thesis`.\item Some of the options, like `m`, are redundant; they could have been written as `option m`.\end{itemize}We would like to optimize this formalization. We do not want to remove the definition of `merge_on`, but it would be nice to fix the redundancies and improve the readability.It would be nice to have a proof assistant that allows us to write proof strategies so that we can automatically optimize, formalize, and optimize the formalization, if needed.This is where Isabelle comes short.Isabelle only allows you to write a proof, and not a proof strategy. This means that a proof strategy has
4.It is not very hard to understand for someone with some knowledge about recursive data structures, but not very easy either.The proof, as stated, is too long to be fully understood.\begin{itemize}\item Could we have a different formulation which would be easier to understand and still be totally correct?\item How can we make sure that our formalizations are easy to understand and maintain?\end{itemize}Comment: How can the informal proof not be totally correct?Comment: @MikeShulman I meant that we can always be sure that the formalization is correct. I will edit the question.Comment: Why do you say "it works and is correct"? What makes you think it works?Comment: @MikeShulman I can always be sure that it works. As for the correctness, I can only be sure that it is correct if I run it through Isabelle.Comment: I'm not sure what you're asking. There are many possible correctness proofs: formal, informal, theorem provers, automated theorem provers, mechanical theorem provers, interactive theorem provers, and so on.
3.This has one line of Isabelle code and 55 lines of Java code.The Java code is not easy to read. If the Isabelle code had a less verbose syntax,the Java code would probably be easier to read.This example shows that the 'correctness' and 'easiness of use' of a formalizationcan be different.One may want to use a different metric to assess the quality.As for now, I will be using the ratio of Isabelle lines to Java lines as anindicator of quality.In this example, I would give a quality of 1/3.\end{blockquote}\end{blockquote}\section{Isabelle/HOL}Isabelle/HOL is an interactive theorem prover for the development of formal proofs, and aims to enable developers to create new verified software and make it publicly available. It is used in the development of a number of high assurance systems in both industry and academia, including the [Linux Kernel](http://www.kernel.org/doc/html/v4.1/process/sec-isabel
3. I do not understand the proof, I do not know if it will still work if I add more definitions, and the author is not clearly explaining his or her intentions. This is a sad example of a proof that is correct, but not as good as it could be.The Isabelle documentation [3] provides some general guidelines and advice for creating formalizations. There are also some examples for Isabelle 2013 and 2018 available on the [Isabelle website](https://isabelle.in.tum.de/pr-examp).\section{Definition}A formal proof is an explanation of how a mathematical statement can be derived from other statements. It should have the following characteristics:\begin{itemize}\item \textbf{Correctness.} The proof should be correct, i.e., it should lead to a derivation of the desired statement.\item \textbf{Completeness.} The proof should be complete, i.e., it should prove all statements that are derivable from the premises.\item \textbf{Well-foundedness.} The proof should not require any non-constructive proofs such
7. It's pretty good.In Isabelle, we use a ``quality'' variable to control the level of quality of a formalization:  \<lbrace>  :quality \<fst> <or>  :quality \<snd> <or>  :quality \<fst> \<and> :quality \<snd>  \<rbrace> \<Longrightarrow> \<forall>M. \<exists>N. \<forall>n. \<forall>x. \<exists>f. \<forall>y. (M (x, y) = f (n, x, y)) \<longrightarrow> M (x, y) = N (f (n, x, y)) \<and> N (f (n, x, y)) = N (f (n, y, x)) \<and> N (f (n, y, x)) = N (f (n, x, y))\<rbrace>The variable ``:quality'' has a default value of 10.As usual, this variable can be bounded. The bound can either be a constant,or a function that takes a positive natural number as an argument
3.This definition can be improved using the following strategies.Issue 1: The definition is not very readable, and will be hard to maintain.Issue 2: The definition is too verbose.Issue 3: The definition uses some of Isabelle's advanced features that are not well understood.For each issue, we will first describe the problem, then suggest a solution.## Issues with readabilityWe have a number of issues here, all of which stem from the fact that the definition is simply too verbose.We can break this definition down into a number of smaller steps.First, we can find a definition for the option merging operation.Next, we need to verify that the definition of this merging operation is well defined.Finally, we need to find a definition for the merkle tree.## Issues with maintainabilityIf the definition is not well written, then it is very hard to maintain.## Issue 1: Definition is not very readableThe definition is not very readable.We can improve the readability
5.\section{Improving Quality}The quality of an Isabelle formalization can be improved by:\begin{itemize}\item \textbf{Using a (slightly) more succinct notation}:We can make use of the fact that every type is a set with a UNIV. We can take this into account and write "set" as a shorthand for "set set UNIV". This gives us the following:\begin{code}lemma merge_tree_cong' [fundef_cong]:  assumes "\<And>'aa 'ab. \<lbrakk> 'aa \<in> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> 'a setset1_rose_tree\<^sub>m ('a, 'b) rose_tree\<^sub>mx; 'ab \<in> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> 'a setset1_rose_tree\<^sub>m ('a, 'b) rose_tree\<^sub>my \<rbrakk> \<Longrightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a optionm 'aa
5.\end{blockquote}Comment: I think this is a rather broad question. There are many issues that could be discussed here. One example is "what is the best way to formulate a rule for a function that accepts an arbitrary number of arguments and can then choose which of these it can use, or not". I've written a blog entry on the topic of this very question a while ago: [Selective arguments](http://blog.inf.ethz.ch/mewhitemore/2011/03/18/selective-arguments.html). I also discuss related issues in [my Isabelle/HOL dissertation](http://diss.inf.ethz.ch/2011/03/18/zot.pdf).Comment: I've put some material in the question, but it's a bit too specific. I should have been more general and asked how to formalize any general process where the process is executed with varying input and an output might be returned.Comment: I've now included a concrete example in the question.Answer: I think the answer to this is "it depends".
3.There are 3 possible flaws in this snippet that we can discuss:\begin{itemize}\item \textbf{Too long}\begin{itemize}\item We don't want readers to be bored\item We don't want developers to become frustrated by long proofs\item We don't want to waste developer time\end{itemize}\item \textbf{Too hard to follow}\begin{itemize}\item We don't want readers to be confused\item We don't want developers to make mistakes\item We don't want developers to waste time\end{itemize}\item \textbf{Likely to break}\begin{itemize}\item We don't want readers to be confused\item We don't want developers to waste time\item We don't want readers to waste time\end{itemize}\end{itemize}We can rate our quality by assessing how well the following criteria are satisfied:\begin{itemize}\item \textbf{Suitable for readers}
7.The following snippet is more complex and would receive a 3 on a scale of 1 to 10,lemma simple_equality_test_simp:  assumes f: "F = G"  shows "F \<equiv> G"proof -  {    assume a: "F = G"    from a obtain F G where a: "F = G"    proof (cases "F = G")      case True:        let ?f = ?G        from a obtain ?F where a: "F = G"        proof (cases "?F = ?G")          case True:            let ?a = ?b            from a obtain ?b where a: "F = G"            proof (simp add: f)              assume a: "F = G"              then have "?a = ?b" by (rule F_eq_G)            qed          case False:            from a obtain ?a where a: "F = G"            proof (simp add: f)              assume a: "F = G"              then have "?f
0.\begin{code}lemma root_hash_G':  "root_hash_G' k =  F (map_comp root_hash_F k) (map_id0 root_hash_T k)"  by (simp add: root_hash_T_def F\<^sub>m.map_comp root_hash_F_def T\<^sub>h.map_id0)\end{code}We can fix this by making the definition of `root_hash_G'` more explicit.\begin{code}lemma root_hash_G':  "root_hash_G' k =  F (map_comp root_hash_F k) (map_id0 root_hash_T k)"  by (simp add: root_hash_T_def F\<^sub>m.map_comp root_hash_F_def T\<^sub>h.map_id0)\end{code}We can further improve this by using Isabelle's match-sometimes extension.\begin{code}lemma root_hash_G':
6. The type checking is a bit hard to read, but it is still readable. The definition of root_hash_G is too long and could be broken.It is not obvious why the type of the root_hash_G_unfold lemma is the same as the definition.It is also not obvious why the type of the final lemma is the same as the definition.Note that this is a trivial example, but in more complex formalizations, there are more complex issues like these.\end{blockquote}In a comment, user "Alec" said that it would be helpful to provide an example of a ``good'' formalization.So here is an example of a formalization of the Fermat little theorem which is very clear, easy to understand, and easy to maintain:\begin{code}theorem "x^2 = x" using fft_little_theorem by simp\end{code}\begin{blockquote}The definition of the theorem is very short: There is one variable, x, and one  assertion. The function used is fft_little_theorem. The type of the function is
3 or 4.\bigskipThis is the quality of the formalization of a lemma that is used in the proof of a theorem.We can always be totally assured that the formalization is correct.However, we are less interested in the correctness of the formalization itself and more interested in the quality.The quality of a formalization is determined by how well it can be understood, how easy it is to maintain, and how easy it is to use.We can always use the Isabelle formalization to check that it is correct and use Isabelle's proof assistant capabilities for this.The question is whether it is easy to understand.This is a highly subjective judgement and depends on the background of the user.We cannot judge the quality of a formalization of a lemma from a theorem.However, we can analyse the quality of a formalization by looking at an example.We can analyse the following snippet.\bigskiplemma root_hash_G_simps [simp]:  "('c \<Rightarrow> 'a) \<Rightarrow> ('d \<Rightarrow> 'b) \<Rightarrow> ('c, '
9 or 10.Unfortunately, there is no more than one correct formalization for a Isabelle specification. It could be the case that two different Isabelle developers, with different backgrounds, write the same formalization. This is the case for a number of our specifications and there are currently no tools to detect this.If the specification is very small (about 50 lines), this can be handled by hand. But for larger specifications, we should rely on some automated tool.This is where Isabelle-Checker comes in. Isabelle-Checker checks the correctness of Isabelle specifications against an automated set of tests.The Isabelle-Checker is made up of a number of different parts:- The Isabelle-Checker server collects all the tests for a given specification and performs a number of checks on the tests.- The Isabelle-Checker client connects to the Isabelle-Checker server and executes the tests.We have a number of tools to help with the tests, one of which is Isabelle-Checker-Parser.The Isabelle-Checker-Parser parses the Isabelle specification
4.\begin{tikzpicture}\matrix (m) [matrix of math nodes,nodes in empty cells,anchor=center,nodes={rectangle,draw,minimum height=1.5em,minimum width=1.5em,align=center,text width=1em},row sep=2ex,column sep=4em] {  & & \\  & & \\  & 10 & \\  & & \\  & & \\  & & \\  & & \\};\draw[->] (m-1-1) to (m-1-2);\draw[->] (m-1-2) to (m-1-3);\draw[->] (m-1-3) to (m-1-4);\draw[->] (m-1-4) to (m-1-5);\draw[->] (m-1-5) to (m-1-6);\draw[->] (m-1-6) to (m-1-7);\draw[->] (m-1-7
5: There are a few issues which I would like to mention.\begin{itemize}\item The type of the inductive definition `blinding_of_T` is misleading. It is not a `T`, but a `blinding_of_T`, but `blinding_of_T` is not the return type, but the name of the inductive definition. This means that we are defining a `blinding_of_T` for each `T`.\item The type of the `if` statement is also wrong. We are taking `blinding_of_T`, but we want the type of the `if` statement to be `bool`. `bool` is the type of the `if` statement, but we want the type to be `boolblinding_of_T`. The type is correct in the inductive definition, but not in the `if` statement.\item The type of the `F` in `T'`, which is used in the `if` statement, is the same as the type of `T`, which means it is the wrong type.\item The type of the `then` is not correct, it should be `bool`.
5.If we were to formalize a more complex Isabelle text thatalso includes definitions and lemmas, we would be able tojudge the quality of the formalization using the followingcriteria.\begin{itemize}\item The definitions of functions are easy to understand.\item The lemmas are easy to understand.\item The proofs are easy to understand.\item The proofs are easy to follow.\item There are no definitions or lemmas that are too complex.\item There are no proofs that are too complex.\item There are no definitions or lemmas that require specialconstructions.\item There are no proofs that require special constructions.\item The definitions and lemmas are easy to maintain.\item There are no proofs that are likely to break with futurechanges.\end{itemize}Isabelle provides a number of helpful tools for verifying the quality of an Isabelle text, in particular, for checking that the text satisfies the different criteria listed above.While we will discuss a few of the tools in this article, it is important to note that Isabelle provides
3 at best. It is not very clear and the proof is too long.Isabelle provides a number of tools to help with the quality of formalizations, such as \verb|Tools_Basis| and \verb|Tools_Metis|. This is helpful but it is still up to the user to provide a quality formalization.\begin{figure}[h]\centering\includegraphics[scale=0.2]{figures/quality_formalization.pdf}\caption{Quality of formalization (formalization quality score 5)}\label{fig:quality_formalization}\end{figure}\paragraph*{Formalizing Correctness}Formalizing correctness of an implementation is quite easy: We just have to state the definition of the function that we want to formalize and give a proof that it is well defined and correct.\begin{figure}[h]\centering\includegraphics[scale=0.2]{figures/correctness_formalization.pdf}\caption{Formalizing correctness (formalization quality score 1)}\label{fig:correctness_form
5. I am not sure if there are better ways to structure this proof (and I am not sure how to phrase this problem).What I am looking for is some guidelines on how to structure formalizations to achieve a higher quality. I understand that it is a complex topic and that it differs from case to case, so I am not really looking for a general solution, but some examples of how to structure a formalization in order to achieve a high quality.Comment: Note that this question is closely related to http://cs.stackexchange.com/questions/1617/how-to-write-a-formal-proof, but with a different scope.Comment: This question is a little unclear, perhaps because it seems to require an answer that is too broad.  We might want to rewrite it to say something like "how to structure a proof of a theorem", or perhaps "how to write a formalization that is clear and easy to understand", etc.Answer: To my mind, the best way to structure a formal proof is to make it a readable argument.I think that there are three important criteria for a formal proof.\begin{itemize}\item
3.\end{blockquote}Comment: I should have added this to the original question. "This is a formal proof, not a proof of correctness, so the converse is not true in general." I agree that a proof-of-correctness has some inherent quality issues. I was hoping to have a reference to point to.
5.\end{document}\end{code}<a href="https://i.stack.imgur.com/pUjN5.png" rel="nofollow noreferrer"><IMAGE></a>If I were doing this, I would use the `defprint` option to produce the source code instead of just outputting a pdf file.Comment: +1 for using `defprint`, but I don't understand the value of the `width` option if you are using the `listings` package.Comment: @Mico I tried to use `height` and `heightrounded`, but it seems to choke. I might do some tests and post a working example.Comment: @Mico Here is a working example: http://pastebin.com/fUJVtJLF .Answer: The following MWE shows how to use `listings` to produce a source code listing that includes the "full source" for a snippet of Isabelle code. It does not use the `width` or `height` options for the source code listing. Instead it uses the `maxdepth` option to limit the number of nested indentations
2 for maintainability. It would be slightly better if the lemma used the name of the module instead of the name of the file (a.k.a. let modules = open_modules in OCaml) and if the type of the first argument was used.This is a nice example because it shows a few different ways to improve the quality of a formalization.\subsection{Consistency}Isabelle/HOL has different internal and external proof systems.External proof systems are used to prove properties of programs. The most important of them are the \texttt{Proof} and \texttt{Proof_Inductive} modules.Internal proof systems are used to prove properties of the Isabelle/HOL language. The most important of them are \texttt{Inductive} and \texttt{Inductive_construction}.The internal proof systems have a few advantages:\begin{itemize}\item Isabelle/HOL is well-defined: Nothing is left to implementation-dependent decisions.\item They are much easier to prove correct.\end{itemize}In other words, the only thing that can go wrong when using
5.\end{document}\end{code}If I look at the output, I see\begin{code}<output>   (proof_goal, proof_goal, proof_goal, proof_goal)   (proof_goal, proof_goal, proof_goal, proof_goal)   (proof_goal, proof_goal, proof_goal, proof_goal)\end{code}and I was hoping to see\begin{code}<output>   (proof_goal, proof_goal, proof_goal, proof_goal)   (proof_goal, proof_goal, proof_goal, proof_goal)   (proof_goal, proof_goal, proof_goal, proof_goal)\end{code}I have tried with\begin{code}\documentclass{article}\usepackage{xparse}\makeatletter\newcommand{\Check}[1]{\ifx#1\relax\else#1\fi}\newcommand{\CheckDef}[1]{\ifx#1\relax\else\isas
7.The quality of a formalization is evaluated on a per-lemma basis. If the quality of a lemma is good, then the quality of the formalization is also good.Formalizations are evaluated and assigned a quality number at the end of the formalization process.This quality rating is stored in a global variable \verb"isabelle_quality_good" which is read at the start of every Isabelle session.```{r}lemma blinding_of_on_G_good:  assumes "'a set \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> boolblinding_of_on 'a setA 'a \<Rightarrow> 'brha 'a \<Rightarrow> 'a \<Rightarrow> boolboa" "'c set \<Rightarrow> ('c \<Rightarrow> 'd) \<Rightarrow> ('c \<Rightarrow> 'c \<Rightarrow> bool) \<Rightarrow> boolblinding_of_on 'c setB 'c \<Rightarrow> 'drhb 'c \<Rightarrow> 'c \<Rightarrow> boolbob"    "'a \<Rightarrow> 'b"
2. It is easily understandable, but the proof is very long and requires to read a lot of other proofs to understand what is going on. It also has a lot of unused lemmas, which makes the proof unmaintainable.\section{Quality as a Formal Attribute}Because we are not interested in quality as an absolute value, but only in changes in quality, we need to find a way of representing this.The Isabelle language is powerful and expressive. If we have a complete formalization, we can even use it to formally specify quality.Let us take the following formalization as an example:\begin{lstlisting}lemma random_to_all_perms_correct:    "random_to_all_perms (perm x) = {perm' x | perm' \<in> {perm x | perm' \<in> Perms(x)}}"endlemma random_to_all_perms_correct':    "random_to_all_perms (perm x) = {perm' x | perm' \<in> {perm x | perm' \<in> Perms
3, just because it is hard to understand.However, as we can see, the formalization uses several lemmas from the library `that` (`of_hmset`, `that_hmset`, `of_hmset_dict`, and `that_hmset_dict`), which were introduced in Isabelle 2015. Isabelle 2015 introduced the notion of \emph{hash sets}. The user can specify a hash set that will serve as a representation for the domain of a particular relation, and the \emph{hashtag} will ensure that the relation is injective. In other words, if a hash set is unique, then the corresponding relation is injective. The hash sets are implemented in the library `that`. The implementation is well-known and well-understood, and should not be a problem to understand.\subsection{Writing a formalization}Let us write a formalization for the problem.First of all, we need to decide which theory to use. Let us go with the theory `that`.\begin{lstlisting}theory thatimports  infixr "\<uparrow>"  inf
7.Here is an example of an Isabelle formalization that I consider unsatisfactory:{  article = "The semantics of the term algebra"  title = "On the semantics of the term algebra"  author = "Victor Galbusera"  volume = "25"  journal = "Foundations of Software Technology and Theoretical Computer Science"  number = "6"  year = "2004"  issue = "2"  pages = "111-126"  address = "Roma, Italy"  month = "July"  month = "July"  email = "victor.galbusera@uniroma1.it"  name = "Victor Galbusera"  affiliation = "Dipartimento di Scienze del Linguaggio, Universita' degli Studi Roma Tre, Roma, Italy"}{  lemma    ctxt [simp]:    "if P then A else B"    [simp]:    "if P then A \<or> B"    [
4. It is still readable and concise, but I often found myself wanting more.The first thing that jumps out is that we are using `type'a\<^sub>m hash` instead of the more general `hash`. As a result, we cannot say that \texttt{merge_T} is only a `merge` between hashes. In fact, it is just a function that takes a \emph{type'a\<^sub>m} hash as an argument.We could say\begin{code}function merge_T :: "(hash, type'a\<^sub>h) T\<^sub>m merge" where\end{code}But we cannot say\begin{code}function merge_T :: "(hash, type'a\<^sub>m T\<^sub>m merge" where\end{code}Because we do not know what `type'a\<^sub>m T\<^sub>m` is (we may be able to define it).The reason for the use of \texttt{type'a\<^sub>m hash} is that it can be used to define the standard functions \texttt{insert
7.\end{example}\section{Interactive Isabelle}Isabelle comes with a built in interactive mode. This means that we can use it like any other interactive computer program. This is very useful for working out proofs and definitions. However, to debug our Isabelle code, it can be very useful to see the internal state of the program. This can be done using the \texttt{display} command.\begin{code}|> display "==> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
1.The next snippet is a formalization that is somewhat more complete. It is still not very good, but at least it works.theory FormalizationIimports  "~~~  *[*int *]: merge_on 'a\<^sub>m set'a\<^sub>m setA 'a\<^sub>m \<Rightarrow> 'a\<^sub>h'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> bool'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> boolbo 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m option'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionm"beginlemma merge_on_same:  "merge_on \<circ> merge_on a \<circ> b = merge_on a \<circ> b"  by (rule ext)lemma merge_on_apply:  "merge_on a (f \<circ> b) \<circ> f \<circ> a = merge_on
2 for "clear" and a 10 for "maintainability".Indeed, it is hard to read and understand what is going on.It may sound obvious, but it is still important to verify that a formalization is as clear as possible.\section{A Simple System}\label{sec:examples}We will first present a simple proof system and then use it to formalize a few simple properties of \texttt{lists}.\subsection{A Simple Formalization}\begin{figure}\begin{isabelle}theory Lists_basic_proofimports "~~~Isabelle/Gentle/Lists_basic.thy"inductive type_is_list :: "'a \<Rightarrow> ('a \<Rightarrow> 'b) -> ('a \<Rightarrow> 'b)"inductive type_is_list_rec :: "'a \<Rightarrow> ('a \<Rightarrow> 'b) -> ('a \<Rightarrow> 'b)"inductive type_is_list_rec_proof_lemma :: "'a \<Rightarrow> ('a \<Rightarrow> 'b) -> 'b
5 for readability. However, this is not an isolated case. There are formalizations that are all over the place. One should not be forced to constantly guess whether a formalization is correct.I propose a solution to these problems.My solution would be to create a web service where Isabelle formalizations could be stored. The service could be a centralized server or distributed servers. The latter being the ideal solution because it would allow for scalability and distributed file storage. The service could be open source or closed source. It could be completely free or paid.This service would be a repository for Isabelle formalizations. Formalizations could be uploaded by any person. The repository would store the formalizations, but also metadata about each formalization. Metadata would include information such as the formalization's author, proof quality, and language it uses. There would be a rating system for each formalization to allow for easy to find, and easy to judge, the quality of formalizations.There would be an API for the service. This API would allow for easy retrieval of formalizations by parameters. A user could then choose to read the formalization, or write a theorem prover plugin that uses the formalization
7.Let us now take another example, which is actually longer, yet easier to understand:Lemma gimp: forall (T: Type) (i: T),   forall (x: T) (y: T),   (i, x) = (i, y) -> x = yProof.  intros.  destruct x, y.  apply i_symm.  assumption.Qed.This is a function, that is defined on pairs, and it uses the symmetry of the identity function. As we can see, this is more elaborate than the first example, but also easier to understand, and follow the steps of the proof.On a scale of 1 to 10, I would give it an 8.The third example is again longer, but the structure of the proof is more complicated.Lemma bike: forall (b: Type) (x: b),  forall (y: b),   (b, x) = (b, y) -> x = yProof.  intros.  destruct x, y.  apply
5.\end{blockquote}You can either give it a try by using [Isabelle/jEdit](http://isabelle.in.tum.de/jEdit/) to edit it, or you can just take the source code and build it using [Isabelle/HOL](http://isabelle.in.tum.de/isabelle) (if you want to actually try running the theory).If you are looking for a theory with a higher quality, [this one](http://isabelle.in.tum.de/repos/isabelle/file/8941a8f37398/main/games.thy) might be a good candidate. It has a score of 9 on [the quality rating](https://isabelle.in.tum.de/repos/isabelle/file/8941a8f37398/main/games.thy) at the Isabelle website.Comment: Thanks for the information. It's certainly a nice looking Isabelle theory with lots of useful features. I'm a bit wary of just
5.The proof of the correctness is a bit more complex as it involves several cases. We cannot see it from here. I will leave the proof for the reader.\end{blockquote}\section{See also}\begin{itemize}\item [How to implement a simple calculator in Coq?](https://stackoverflow.com/q/32664621/780717)\item [How to use Coq to formally verify "SAT"?](https://stackoverflow.com/q/27789086/780717)\item [How to make Coq verify that a program is Turing complete?](https://stackoverflow.com/q/29566665/780717)\item [Are there any good books about writing formal specifications using Coq?](https://stackoverflow.com/q/29836882/780717)\item [How to test Coq formalizations?](https://stackoverflow.com/q/20898287/780717
3 (out of 10).The first point of criticism is that the definition of \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{merge_G} is not given, and thus is not understandable. This definition is not even given as a lemma, but as a functional declaration.\lstinline[language=Isabelle,basicstyle=\small\ttfamily]{merge_G} is defined as a \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{fun} for a given \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{list} \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{X}, \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{list} \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{Y}, \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{list} \lstinline[language=Isabelle,basicstyle=\small\ttfamily]{M} and \lstinline[language=Isabelle,basicstyle=\small\tt
4.Isabelle can then automatically check for the quality of the formalization.\section{Quality}Let us look at the snippet again, but this time with the quality checks turned on.The quality checks are provided as the Isabelle plugin \em{mpscheck} that is located in the \em{/plugins/mpscheck} subdirectory of the Isabelle installation directory.\begin{code}Unfolding:unfolding merge_on_GDefinition:Definition merge_G:  assumes a: "'a\<^sub>m set \<Rightarrow> ('a\<^sub>m \<Rightarrow> 'a\<^sub>h) \<Rightarrow> ('a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> bool) \<Rightarrow> ('a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m option) \<Rightarrow> boolmerge_on 'a\<^sub>m setA 'a\<^sub>m \<Rightarrow> 'a\<^sub>hrha 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> bool
5.The next snippet is a little better.proof -  interpret a: merge_on 'a\<^sub>m set'a\<^sub>m setA 'a\<^sub>m \<Rightarrow> 'a\<^sub>h'a\<^sub>m \<Rightarrow> 'a\<^sub>hrha 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> bool'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> boolboa 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m option'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionma by fact  interpret b: merge_on 'b\<^sub>m set'b\<^sub>m setB 'b\<^sub>m \<Rightarrow> 'b\<^sub>h'b\<^sub>m \<Rightarrow> 'b\<^sub>hrhb 'b\<^sub>m \<Rightarrow> 'b\<^sub>m \<Rightarrow> bool'b\<^sub>m \<Rightarrow> 'b\<^sub>m \<Rightarrow> boolbob
7, and I will explain why.\section{1. The definition of `bool?`}A clear, concise and consistent notation is vital for formalizations. Here, `bool?` is too short and too ambiguous to be useful.It would be better to write `bool? bool?`, which defines a predicate that checks whether a boolean is a boolean. It is more concise and more consistent with Isabelle's other notation: `bool?` is the infix operator \emph{not}.We could also make `bool?` a bit longer and use a symbol for its type:\begin{itemize}\item `bool? :: bool -> bool`, where `bool` is a type that represents a boolean.\end{itemize}\section{2. The definition of `bool?thesis`}The definition of `bool?thesis` is too complicated and the code is not easy to follow.In addition to its two parameters, `bool?thesis` is expected to return a boolean. The definition of `bool?thesis` should therefore use the type `bool` as a return type.\section{3. The proof
4.\end{lstlisting}\begin{lstlisting}[style=sml]lemma combine_G_on_split_m:  "('a, 'b) G\<^sub>m a\<^sub>m \<Rightarrow> ('a, 'b) G\<^sub>m b\<^sub>m \<Rightarrow> ('a, 'b) G\<^sub>m a\<^sub>m b\<^sub>m"proof -  let ?c =    "('a, 'b) G\<^sub>m a\<^sub>m \<Rightarrow> ('a, 'b) G\<^sub>m b\<^sub>m \<Rightarrow> ('a, 'b) G\<^sub>m a\<^sub>m b\<^sub>m"  then have "?c a\<^sub>m a\<^sub>m \<Rightarrow> ?c a\<^sub>m b\<^sub>m \<Rightarrow> ?c a\<^sub>m b\<^sub>m"    by (simp add: combine_G_on_split_m_def merge_G_cong)  then have "?c a\<^sub>m b
10.Then, the following snippet is of a very different quality. It is much less understandable, less maintainable, and less easy to use.\begin{code}lemma is_right_map_option_sym_iff :  "[ 'a \<turnstile> 'b \<mapsto> 'c \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow> 'f ]    [ 'a \<turnstile> 'b \<mapsto> 'c \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow> 'f ]    [ 'a \<turnstile> 'b \<mapsto> 'c \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow> 'f ]    [ 'a \<turnstile> 'b \<mapsto> 'c \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow> 'f ]    [ 'a \<turnstile> 'b \<mapsto> 'c \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow> 'f ]    [ 'a \<turnstile> 'b \<mapsto> 'c \<Rightarrow> 'd \<Rightarrow> 'e \<Rightarrow> 'f ]    [
5.\end{blockquote}\section{A quick rant}Formalizations are not \em{proofs}.Proofs have the following properties:\begin{itemize}\item They are always correct\item They are always verifiable\item They are always understandable\item They can be proven\end{itemize}Formalizations do not have these properties.\begin{itemize}\item Formalizations can be incorrect\item Formalizations can be unverifiable\item Formalizations can be un-understandable\item Formalizations cannot be proven\end{itemize}The Isabelle community are quite fond of proofs, and it is tempting to look at Isabelle formalizations as proofs. But they are not.\section{Further reading}\begin{itemize}\item [Isabelle-FoC]\end{itemize}Answer: There is a difference between the formalization and the source code.  The source code is written by an author, which can make mistakes and also change the semantics of a piece of code over time
5. It could be better, but it is quite good for a first try.We can also use [Verifier] to obtain a certificate that this formalization is correct.```(*** Verify *)Verifier verifier_new =  Verifier {t = 0, n = 0, c = 1, v = 1, v_opt = 1, e = 1, e_opt = 1, e_sub = 1, e_not = 1, e_opt_not = 1, e_sum = 1, e_sum_opt = 1}with_invariant  Fixpoint (const i) (const l) (const m) (const h) (const r) (const adata) (const trees) (const list) (const lis) (const l_subs) (const l_nots) (const l_opts) (const l_opt_nots) (const l_sums) (const l_sum_opts) (const l_sum_opt_nots) (const l_sums_opts) (const l_sum_
4.\end{document}\end{code}Now, when I compile the above snippet, I get the following error message:\begin{code}(/usr/local/texlive/2013/texmf-dist/tex/latex/expl3/expl3.sty:285: C:\Users\Mika\AppData\Local\MiKTeX\2.9\tex\latex\expl3\expl3.sty:1012: C:\Users\Mika\AppData\Roaming\MiKTeX\2.9\tex\latex\expl3\expl3.sty:1012:! You can't say 'c because there is a name clash between the macroand the special symbol \'c. If you had used \c instead of \'c,then you could have typed ''c.! You can't say 'c because there is a name clash between the macroand the special symbol \'c. If you had used \c instead of \'c,then you could have typed ''c.\end{code}
6. It is understandable, maintainable, and easy to use.Note that one does not have to be a master at formal logic to create a good Isabelle/HOL formalization.A good Isabelle/HOL formalization is not a big formalization.It is a small formalization that is clear, maintainable, and easy to use.(* ##################################################### *)(** * Declaration of [Proof Isomorphisms] *)(** We introduce a new function for finding proof isomorphisms. *)Inductive proof_isomorphism : "('a \<Rightarrow> 'b) \<Rightarrow> ('c \<Rightarrow> 'd) \<Rightarrow> ('a, 'b) \<Rightarrow> ('c, 'd) \<Rightarrow> bool" where  "proof_isomorphism X X 0 0 = true" |  "proof_isomorphism X Y 0 p a \<Longrightarrow> proof_isomorphism X Y p (p a) 0" |  "proof_isomorphism X Y 0 p a \<Longrightarrow> proof_isomorphism Y X p (p a) 0" | 
7.Let us now consider the following piece of Isabelle code:fun  children :: "'a rose_tree \<Rightarrow> 'a rose_tree list" where    "'a rose_tree \<Rightarrow> 'a rose_tree listchildren ('a \<times> 'a rose_tree list \<Rightarrow> 'a rose_treeTree ('adata, 'a rose_tree listsubtrees)) = 'a rose_tree listsubtrees"    "('a, 'a\<^sub>h) rose_tree\<^sub>m \<Rightarrow> ('a, 'a\<^sub>h) rose_tree\<^sub>m listchildren\<^sub>m (('a \<times> ('a, 'a\<^sub>h) rose_tree\<^sub>m list, 'a\<^sub>h \<times> 'a\<^sub>h rose_tree\<^sub>h list) blindable\<^sub>m \<Rightarrow> ('a, 'a\<^sub>h) rose_tree\<^sub>mTree\<^sub>m ('a \<times> ('a, 'a\<^sub>h) rose_tree\<^sub>m list \<Rightarrow> ('a \<times>
10.Let us now take a look at the same snippet, but with a little change.lemma splits_iff: "('a listl, 'aa, 'a listr) \<in> ('a list \<times> 'a \<times> 'a list) list \<Rightarrow> ('a list \<times> 'a \<times> 'a list) setset ('a list \<Rightarrow> ('a list \<times> 'a \<times> 'a list) listsplits 'a listll) = ('a listll = 'a listl @ 'aa # 'a listr)"  by(induction 'a listll arbitrary: 'a listl 'aa 'a listr)(auto simp add: Cons_eq_append_conv)type_synonym 'a path_elem = "{}'a \<times> {}'a rose_tree list \<times> {}'a rose_tree list"type_synonym 'a path = "{}'a path_elem list"type_synonym 'a zipper = "{}'a path \<times> {}'a rose_tree"definition zipper_of_
6.The snippet is correct, but could be improved.\begin{enumerate}\item `case_of_simps` and `zipper_children` have their own definitions in `tree_of_zipper_cases` and `zipper_children`. This looks like a duplication of definitions and we would like to avoid that.\item We have the implication `simps = rose_tree`, but no definition for `simps`. This makes it hard to read.\item We have a definition `simps = rose_tree` but use the function `rose_tree` in the lemma `tree_of_zipper_id`. This makes it hard to read.\item There are two different ways of defining the `zipper_children` type, the `case` of `z` and the `type` of `z`. Both definitions are needed.\item The definitions `case` of `simps` and `type` of `zipper_children` are not visible in the proof of the lemma `tree_of_zipper_id`.\end{enumerate}The above is a set of issues that are already known from
7. But there are some things that I do not like:  - This is a proof of the following theorem:    http://wiki.common-lisp.net/display/cl/Tree+of+Zippers  - I do not know what the type of the result of zipper_children_same_tree is, it is not clear.  - I do not know what the type of the result of tree_of_zipper_children is, it is not clear.  - The proof of the first lemma is not too informative.  - There are no comments in the code, which makes it hard to understand what is happening.Consider the following example:(* ex *)lemma zipper_children_same_tree_compressed:  assumes "('a \<times> 'a rose_tree list \<times> 'a rose_tree list) list \<times> 'a rose_tree list \<in> (('a \<times> 'a rose_tree list \<times> 'a rose_tree list) list \<times> 'a rose_tree) list \<Rightarrow> (('a \<times> 'a rose
5.The quality of formalizations can be increased by adding definitions and lemmas, and by using notation that is as concise and clear as possible.What does it mean for a formalization to be understandable?Understandability is not just about the clarity of the formalization, but also about how easy it is to comprehend the proof that the formalization is correct.It means that we should be able to quickly understand the proof that a formalization is correct.A good formalization should have:\begin{itemize}\item A few definitions, and these definitions should be used as often as possible.\item As few lemmas as possible, and these lemmas should be used as often as possible.\item As few assertions as possible, and these assertions should be used as often as possible.\end{itemize}These rules can be formulated in terms of induction:\begin{itemize}\item Defined terms are used as often as possible.\item Formalizations should be as simple as possible.\item Definitions should not be too big.\end{itemize}This
5.Definition f4 :: "('a, 'b) Zipper \<Rightarrow> 'a \<Rightarrow> 'b" where  "f4 (Zipper' hl tl) x = fmap' x (Zipper' hl tl)"This definition is good. It is clearly correct, and could be made more precise, but is not likely to be wrong, assuming the `fmap'` function is defined correctly.Definition f4 :: "('a, 'b) Zipper \<Rightarrow> 'a \<Rightarrow> 'b" where  "f4 (Zipper' hl tl) x = fmap' x (Zipper' hl tl)"This definition is bad. It is incorrect. The result type of `fmap'` is `(a -> b) -> (a -> b)`. However, the result of `f4` is simply `a -> b`. The type `f4` will not work at all.Definition f4 :: "('a, 'b) Zipper \<Rightarrow> 'a \<Rightarrow> 'b" where 
3.\subsection{Quality Scoring}This metric attempts to measure the quality of a formalization.\subsubsection{Definition}We model the quality as a probability distribution over all possible outputs of Isabelle, given a formalization.\subsubsection{Training}We train our model on the Isabelle definition and lemma database. To do so, we use a sliding window approach. We select a sliding window of width 200 (the maximum Isabelle definition size). Then, we query the definition and lemma database for definitions and lemmas between the 100th and 200th definition and lemma of the sliding window. We score all of the definitions and lemmas in the window.For each definition and lemma, we return the probability that the definition or lemma is correct as defined by the Isabelle engine.\subsubsection{Fitting the Model}We can now fit the model. We use the training data to fit a Gaussian Process Model. The score of a definition or lemma is the Gaussian Process output of the definition or lemma.\subsubsection{Implementation}The implementation is quite simple. We use
9.%%%%    The Isabelle-specific \`qualified\` directive is the most commonly used way of marking Isabelle's quality of formalizations.    For example, the following definitions are \`qualified\`:    - The definition of `enum` in [1].    - The definition of `flip` in [2].    Both are indented using the \`qualified\` directive, although `enum` is also indented using the \`infix\` directive.    [1] http://www.cs.indiana.edu/~vitanyi/enum.pdf    [2] http://www.cs.indiana.edu/~vitanyi/flip.pdf%%%%    The following definitions are not \`qualified\`:    - The definition of `set` in [3].    - The definition of `skip` in [4].    [3] http://www.cs.indiana.edu/~vitanyi/set.pdf    [4] http://www
5. The code is understandable, but it is a bit verbose and does not follow the commonly used patterns. For example, I would have expected to have the definitions of the mapping functions as free variables instead of local variables.\end{blockquote}You can also look at [how you can improve the quality](https://isabelle.in.tum.de/docs/developing-formalizations/quality.html) of a formalization.Comment: Thanks for the tip about the "developing-formalizations" file.
2.\item Isabelle can also be used to build interactive and dynamic provers, such as proof assistants. These provers are a bit more difficult to describe formally. Instead of starting from scratch, we can import the already-defined notions and definitions from Isabelle. This is typically done with the use of \textbf{role} and \textbf{encoding} definitions. The following snippet demonstrates a very simple example:\end{itemize}\begin{code}import "'a \<Rightarrow> 'b"role "prefix"enc "<", ">", "add", "add1", "add2" :: "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b)"def add_rec_prefix (a: 'a) (b: 'b) (c: 'c) (d: 'd) (e: 'e) (f: 'f) :=  if a = 0 then b else if c = 0 then f else if d = 0 then e else if f = 0 then
9 for clarity.The type `path` is written as `('a, 'a)` and it is the type of paths. The types `type'a` and `type'a\<^sub>h` are the types of elements of the paths. The type `'a path` is written as `('a, 'a)` and it is the type of paths. The type `type'a path` is the type of elements of paths.If we look at the case type `case_of_simps`, we see that it has the following signature:case_of_simps :: "('a \<Rightarrow> 'b) \<Rightarrow> ('a, 'b) path"This is written as `('a, 'b) path`. The type `('a, 'b) path` is the type of paths. The type `('a, 'b)` is the type of elements of the paths.The following is a snippet of a definition `simps_of_path` which is part of the definition of `case_of_simps`. I will not put the whole definition here as it is long and repetitive. I will just pick up the
6.\begin{itemize}  \item Clear: (1)  \item Maintainable: (1)  \item Easy to read: (0)  \item Easy to understand: (0)  \item Easy to use: (0)  \item Writable: (0)\end{itemize}\end{blockquote}Comment: I don't want to be rude, but that's a rather wooly answer.Comment: I can imagine what you mean by `wooly`, but I don't know how to improve it.Comment: I mean it's not really an answer to the question. You could make it an answer by adding examples of "where" clauses that you deem correct and why they are so.Comment: "where" clauses are not part of the definition. They are the implementation of the definition. I already said that "where" clauses should be minimal and clearly specified. I did not find any of these criteria violated in that snippet. I added an example that is missing in the original snippet and that example shows that the definition is
3.This is not the best way to write such a proof, and if I were to make this proof into a real Isabelle formalization, I would use a nicer structure.There are several things that make this proof suboptimal. It should be easier to understand and follow what is happening, it should be easier to reuse parts of it, and it should be easier to add or modify parts.Let us rewrite this proof:\begin{code}lemma hash_tree_of_zipper_same_path:    "hash_tree_of_zipper_same_path = (\<lambda> (o, st, h) (b, a) st'.                                        h_apply st h (o, st, b) st' = (o, st', a) \<and> h_apply st' h (o, st', a) st' = (o, st', b))                                      (hash_tree_of_zipper_same_path o st h)"lemma hash_tree_of_zipper_same_path':    "hash_tree_of_zipper_same_path' =
1. Let us assume that the full proof is more readable and better documented, and that all relevant definitions and lemmas are included. Then it might be a 7 or 8.Isabelle lets the user decide how to assess the quality of a proof. Using a score on a 1 to 10 scale is an easy way to do this. The user can use different scales for different aspects of quality, such as understandability and maintainability.\end{blockquote}Now, this is not a new feature in Isabelle2021, it was already present in Isabelle2018, so I am not sure where the OP got the idea that this is a new feature.However, the score is not a standard feature in Isabelle. It can be accessed using the `score` function, which returns the current quality score of the proof, but that is an internal implementation detail of Isabelle. The [documentation](https://isabelle.in.tum.de/doc/isabelle2018/developing-isabelle/using-isabelle/score.html) says:\begin{blockquote}The score is not
2.\begin{verbatim}lemma hash_view_zipper_eqI:  assumes "a = xi zi i"  and "a = xj zj j"  shows "xj zi i = xj zj j"proof -  have "zi = 0" by auto  have "zi = 1" by auto  have "zi = 2" by auto  from "zi = 0" have "zj = 0" by (auto simp: hash_view_zipper_eq)  from "zi = 1" have "zj = 1" by (auto simp: hash_view_zipper_eq)  from "zi = 2" have "zj = 2" by (auto simp: hash_view_zipper_eq)  from "zj = 0" have "xj = zj" by (auto simp: hash_view_zipper_eq)  from "zj = 1" have "xj = zj" by (auto simp: hash_view_zipper_eq)
3.Now let us see how it looks in Isabelle2018:<figure><img src="https://i.stack.imgur.com/nLn1E.png" alt=""></figure>Apart from the different formatting, the following appears:\begin{itemize}\item Additional definitions:\begin{itemize}\item 'b \<times> ('b, 'a) rose_tree\<^sub>m list \<times> ('b, 'a) rose_tree\<^sub>m list = 'a rose_tree\<^sub>m list \<times> ('a, 'b) rose_tree\<^sub>m list.\item 'a rose_tree\<^sub>m list \<times> ('a, 'b) rose_tree\<^sub>m list = 'a rose_tree\<^sub>m list \<times> ('a, 'b) rose_tree\<^sub>m list.\end{itemize}\item Additional lemmas:\begin{itemize}\item by(induction 'b \<times> ('b, 'a) rose_tree\<^
5.* ''Of course, we can always be totally assured that it is correct.''There is no guarantee that an Isabelle formalization is correct.* ''However, quality can vary: Formalizations need to be understandable, maintainable, and easy to use.''That is an opinion. If someone is working on a specific project where clarity is paramount, then they may take this criterion very seriously.* ''Unclear definitions, proofs that are too hard to follow, and proofs that are likely to break with future changes are all problematic and should be avoided.''This is a matter of taste. Some people prefer to have proofs that are as short as possible, while others prefer to have proofs that are as long as possible. Some people prefer to have definitions that are as terse as possible, while others prefer to have definitions that are as long as possible.* ''Let us take the following snippet as an example:''Examples are always nice.* ''proof -''This is not a valid syntax.* ''have "('b \<Rightarrow> 'a) \<Rightarrow> 'b \<times> ('b, 'a
7.The proof is correct, but it is hard to follow. There are a few things to say about this proof:\begin{itemize}\item The induction is not explicitly mentioned.\item The lemma's name is not as descriptive as it could be.\item There are many lemmas with the same name and the same proof method.\item The definition is not mentioned, and the proof method is not mentioned either.\item The proof is hard to read and follow.\end{itemize}We will now turn this into a better formalization:\begin{code}lemma childz_same_tree:  "(('a rose_tree listl, 'a rose_treet, 'a rose_tree listr) \<in> ('a rose_tree list \<times> 'a rose_tree \<times> 'a rose_tree list) list) \<Rightarrow> ('a rose_tree list \<times> 'a rose_tree \<times> 'a rose_tree list) setset ('a rose_tree list \<Rightarrow> ('a rose_tree list \<times> 'a rose_tree \<times> '
10!However, the argument given is not clear. It looks like the lemma is trying to prove the following,\[\begin{aligned}\mathrm{blinding}\; \mathrm{of}\; \mathrm{the}\; \mathrm{same}\; \mathrm{path}\; \mathrm{is}\; \mathrm{obvious}.\end{aligned}\]However, this is not the case. Instead, we have to prove the following.\[\begin{aligned}\mathrm{blinding}\; \mathrm{of}\; \mathrm{the}\; \mathrm{same}\; \mathrm{path}\; \mathrm{is}\; \mathrm{true}.\end{aligned}\]The first line of the lemma is simply an hypothesis.\subsection{Formalization vs English}\label{sec:formalization_vs_english}When formulating theorems, it is important to always be as clear and precise as possible.The Isabelle formalization language is capable of representing much more than mere English, and Isabelle will not guess what we mean.Thus, we should be
3.Another formalization that was also in the same category would look like this:lemma -  interpret a: blinding_of_on 'a set'a setUNIV 'a \<Rightarrow> 'b'a \<Rightarrow> 'bh 'a \<Rightarrow> 'a \<Rightarrow> bool'a \<Rightarrow> 'a \<Rightarrow> boolbo by fact  interpret tree: blinding_of_on ('a, 'b) rose_tree\<^sub>m set('a, 'b) rose_tree\<^sub>m setUNIV "('a \<Rightarrow> 'b) \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> 'b rose_tree\<^sub>h('a \<Rightarrow> 'b) \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> 'b rose_tree\<^sub>hhash_tree 'a \<Rightarrow> 'b'a \<Rightarrow> 'bh" "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a, 'b) rose_tree\<^sub>m
3.--------------------------------------------------------------------------------- Incorrect Isabelle definitions-- Isabelle proves the correctness of a definition, but it is up to us to-- ensure that the definition is correct in the first place.--------------------------------------------------------------------------------- The following is an incorrect definition.  It is missing an important-- definition, namely that of the set of all subsets of a set.-- (by_eq)context fixes e :: "nat \<Rightarrow> nat" begin  definition "subsets" (sets :: "set \<Rightarrow> set") where    "sets (X \<inter> Y) = sets (X \<inter> Y)"  enddefinition "fun_in" :: "'a \<Rightarrow> 'b" where  "fun_in f = (\<lambda>a. f (a))"definition "fun_out" :: "'a \<Rightarrow> 'b" where  "fun_out f = (\<lambda>a. f (a))"definition "subsets_eq" (X :: "'a set" & Y :: "'a set") where  "
4.The Isabelle library can improve the quality of formalizations.\begin{center}\begin{tabular}{|c|c|}\hline\multicolumn{2}{|c|}{\textbf{Quality improvement}}\\\hline\hline\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c|}{}&\\\multicolumn{1}{|c
4:\begin{itemize}\item Aesthetics: 2. The first sentence is unnecessarily long, and the lack of indentation is a problem (hint: tabbing is your friend).\item Understandability: 2. The long definition is confusing.\item Maintenance: 4. The code is correct and reasonably understandable.\item Easy to use: 4. It is easy to use in Isabelle, because it is correct.\end{itemize}The last point is the most important: It is correct, which means that the quality is high. However, it is not easy to use because it is too long, and there is too much information in one place.\section{Achieving high quality}To improve the quality of formalizations, we have to find a compromise between correctness and usability.The good news is that the Isabelle language has support for that. It allows us to encapsulate information in a way that is convenient to write and read, while ensuring that the encapsulated information is correct.In the example above, we are using the `case' and
5.\begin{quote}The proof could be shorter and clearer, the code does not look clean, and the definition of `blinding_of_on' is hard to understand.\end{quote}Isabelle does not let us down here, because it provides us with many tools that allow us to get a better quality formalization.\subsection{Guidelines}\label{sec:guidelines}Some general guidelines that can be useful for improving the quality of your Isabelle formalizations are the following:\begin{itemize}\item Start with a simple example.\item Use simple notations.\item Put an emphasis on small-scale formalizations:\begin{quote}For example, consider the following snippet for a simple proof that `0 = 0':\begin{verbatim}lemma 0_eq_0_p:  shows (0 = 0)\end{verbatim}It is clearly wrong, and it is not difficult to see how to fix it.\end{quote}\item Check your code with \
5.\section{Formalizations should be of a high quality.}This means they should be \textit{understandable}, \textit{maintainable}, and \textit{easy to use}.We have seen that the quality of formalizations can vary, but that all formalizations are always correct.In this section we want to discuss the qualities of Isabelle/HOL formalizations.In particular, we will answer the following questions:\begin{itemize}\item What should the quality of a formalization be?\item How can we assess the quality of a formalization?\end{itemize}\subsection{What should the quality of a formalization be?}We want formalizations that are\begin{itemize}\item \textbf{understandable:}\begin{itemize}\item A formalization should be understandable.\item A formalization should not be too verbose and difficult to read.\item A formalization should not contain unnecessary proofs.\end{itemize}\item \textbf{maintainable:}\begin{itemize}\item A formalization should be
6 or 7.This is where Isabelle can help, by giving us a tool to automatically assess the quality of a formalization.Isabelle supports various metrics to automatically assess the quality of formalizations.Here are some examples of metrics that you can use:\begin{itemize}\item \textbf{Least paths metric.}It measures the number of paths in a program, such as the number of proofs of a theorem, the number of lemmas, the number of subgoals etc.\item \textbf{Syntactic complexity metric.}It measures the length of the source code, such as the number of lines of code, the number of characters, the number of comments, etc.\item \textbf{Indentation metric.}It measures the level of indentation of the program, such as the number of indentation levels, the number of blank lines, etc.\item \textbf{Distance metric.}It measures the distance between formal proofs, such as the number of steps in the proof, the number of false steps, etc.\item \textbf{Dead code metric.}It measures the length of dead code, such as
5.\begin{blockquote}The most obvious issues are:\begin{itemize}\item `simplify` is used instead of `simpl`\item the theorem statement does not have a premise\end{itemize}\end{blockquote}Isabelle is able to figure out which of these is the real problem, and a combination of `simpl` and `simplify` will yield the following:\begin{code}lemma blinding_of_tree'':  assumes "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> ('a, 'b) rose_tree\<^sub>m \<Rightarrow> boolblinding_of_tree 'a \<Rightarrow> 'bh 'a \<Rightarrow> 'a \<Rightarrow> boolbo     (('a \<times> ('a, 'b) rose_tree\<^sub>m list \<times> ('a, 'b) rose_tree\<^sub>m list) list \<times> ('a, 'b)
9.We can also see that the definitions are quite understandable. The authors of this Isabelle work clearly thought about how to present the idea in a clear way to the reader.Finally, the formalization was maintainable. There were no errors while checking the formalization and adding new lemmas.As for the last criterion, the formalization was easy to use. Isabelle does have some steep learning curve, but this one was easy to use and understand.Therefore, this is a good example of a quality formalization that is correct and easy to use.\end{document}\end{code}Comment: This is not an answer, but a comment.Comment: @Mico I'm using this box to write my thesis. I have the code in a separate file, and I use a `\includepdf` command to include it in the thesis. I have the same problem with the `changetime` and `changetype` commands. I could provide a MWE if that would be more useful.Comment: @Mico I've updated the answer with some MWE code.Comment:
2:* Forms are too long. I would have written it as:lemma comp_fun_idem_merge: "('a\<^sub>m \<Rightarrow> 'a\<^sub>m option \<Rightarrow> 'a\<^sub>m option) \<Rightarrow> boolcomp_fun_idem (\<lambda>'a\<^sub>mx 'a\<^sub>m optionyo. 'a\<^sub>m optionyo \<bind> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionm 'a\<^sub>mx)"* It is difficult to follow. I would have written it as:lemma comp_fun_idem_merge: "('a\<^sub>m \<Rightarrow> 'a\<^sub>m option \<Rightarrow> 'a\<^sub>m option) \<Rightarrow> boolcomp_fun_idem (\<lambda>'a\<^sub>mx 'a\<^sub>m optionyo. 'a\<^sub>m optionyo \<bind> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionm 'a\<^sub>mx)"
10 for correctness, 4 for understandability, and 3 for maintainability.However, we can see how this is not satisfactory for a large formalization.\section{The Isabelle Formalization}Isabelle provides a formal proof assistant for the specification of mathematical and logical statements. It is widely used in the computer science and mathematics research communities.\subsection{The Formalization}The Isabelle formalization of the [Merge] algorithm is based on two core libraries of Isabelle:\begin{itemize}\item \texttt{option} for the specification of sets of options and the functions that operate on them\item \texttt{algorithm} for the specification of algorithms\end{itemize}The library \texttt{option} was designed to capture the essence of set-based options, but it has enough features to also serve as a general library for manipulating sets of elements. This allows it to serve as a general library for generic set-based algorithms.The library \texttt{algorithm} is a very general library for manipulating algorithms, but it is tailored for generic algorithms that operate on sets of elements. As
6.Let us look at the same snippet again.We can always be sure that it is correct.However, if we are to use it in a project that is in production, we want it to have a certain quality.The following problems would cause us to lower the quality of the snippet:* Unclear definitions - The user might have problems understanding what is going on.* Proofs that are too hard to follow - The user might not be able to understand the proof.* Proofs that are likely to break with future changes - If the definition changes, the user would have to fix all proofs.To address these issues, we could use Isabelle's helpers.For example, we can use the function [inspect](https://isabelle.in.tum.de/doc/main/def/inspect) to display a proof's structure as a tree.We could also use the helpers [clarify](https://isabelle.in.tum.de/doc/main/def/clarify) and [localise](https://isabelle.in.tum.de/doc/
5.\end{code}Comment: See https://github.com/isaac-jlee/Isabelle2020/blob/152b0d47976149c3d71a75f901d83d45f075052d/src/Natural_Deduction/NatDeduce_Sorts.thy#L320-L327 for the details.Comment: @IsaacLee Thanks. This makes the proof complete, but it is still incomplete in the sense that it does not give a proof for the non-existence of the type. The proof for the existence of the type is just like a "deduction theorem" that establishes a proof for a single case. But it does not provide a proof for the non-existence of the type. The proof that I am looking for would be like a [deduction theorem](https://plato.stanford.edu/entries/deduction-theorem/) that establishes a proof for all cases.
5.\end{code}How can I implement such a quality assessment mechanism into Isabelle/HOL?Comment: One way of doing this is to use the `Quality` package. See the [Quality Tutorial](https://isabelle.in.tum.de/dist/Isabelle2018/doc/tutorial_Quality.pdf) for a simple example.Comment: Since you are new to Isabelle, I would advise you to play with `Quality` and get acquainted with it.Comment: Thanks for the tip, I will certainly have a look at it. However, the `Quality` package is not available in the Stable branch of Isabelle, so I might not be able to use it on the codebase I am working on.Comment: @PeterDürr: It's not available in the stable branch, but you can build the stable branch and use it anyway.Answer: You can use the [Quality](https://isabelle.in.tum.de/dist/Isabelle2018/doc/tutorial_Quality.pdf) package. The
9. I would remove the "then" keyword to make the proof a little less wordy, and I would use more white space.Is this standard? Are there any established guidelines for writing good Isabelle formalizations?Comment: I am not a formalization expert, but I would not say that this is standard. I believe that if the proof is too hard to follow, it may lead to the conclusion that the formalization is non-standard. However, I could be wrong.Comment: Could you explain what exactly "does not scale" means?Answer: I can’t comment on your specific formalization, but the general question seems to be interesting.The following general guidelines for writing Isabelle proofs might be of interest to you (see [here](http://isabelle.in.tum.de/doc/isabelle_doc/current/library/Basics/Formalization.html#sec1210)):\begin{itemize}\item Write as few lines as possible, without losing correctness\item When in doubt, use the `show` tactic\item If a proof is hard to understand, split it
3. The proof of Merge_upper is too long, and the proof of Merge_least is missing. The definitions should be given a closer look too.With Isabelle, we can always be certain that our formalization is correct. However, the quality can vary.Let us take the following snippet as an example:lemma Merge_upper:  assumes m: "'a\<^sub>m set \<Rightarrow> 'a\<^sub>m optionMerge 'a\<^sub>m setA = 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionSome 'a\<^sub>mx" and y: "'a\<^sub>my \<in> 'a\<^sub>m setA"  shows "'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> boolbo 'a\<^sub>my 'a\<^sub>mx"  proof -    have "'a\<^sub>m set \<Rightarrow> 'a\<^sub>m optionMerge 'a\<^sub>m setA = 'a\<^sub>m set \<Rightarrow> 'a\<^sub>m optionMerge ('a\<^sub>m \<
7. It is not bad but it could be improved.Now, let us look at a similar snippet which is perfectly fine (I think it is perfect):lemma Merge_finitem:  assume f: "boolfinite 'a\<^sub>m setA"  show "('a\<^sub>m \<Rightarrow> 'a\<^sub>m optionFinite_Set.fold (\<lambda>'a\<^sub>mx 'a\<^sub>m optionyo. 'a\<^sub>m optionyo \<bind> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionm 'a\<^sub>mx) ('a\<^sub>m \<Rightarrow> 'a\<^sub>m optionSome 'a\<^sub>ma) 'a\<^sub>m setA) = 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionFinite_Set.fold (\<lambda>'a\<^sub>mx 'a\<^sub>m optionyo. 'a\<^sub>m optionyo \<bind> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>
6, which is above average.\subsection{Impredicativity}In Isabelle, it is possible to prove proofs using higher-order logic.This allows us to use expressions that have no value, i.e. they take no argument.For example, we can prove the following:\begin{lstlisting}lemma Merge_0_1_finset:  "\<forall>'a\<^sub>ma \<in> 'a\<^sub>m setA. 'a\<^sub>ma \<in> 'a\<^sub>m setA"proof -  have f: "('a\<^sub>m \<Rightarrow> 'a\<^sub>m option \<Rightarrow> 'a\<^sub>m option) \<Rightarrow> 'a\<^sub>m option \<Rightarrow> 'a\<^sub>m set \<Rightarrow> 'a\<^sub>m optionFinite_Set.fold (\<lambda>'a\<^sub>mx 'a\<^sub>m optionyo. 'a\<^sub>m optionyo \<bind> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m \<Rightarrow> 'a\<^sub>m optionm 'a
2. This is because we have a lot of "assume" in this proof, and some of the definitions are missing. For example, what is the domain of the function "vimage2p"?To help the developer, we might want to provide some quality assessments. In a formalization of a theorem (such as the one presented above), we could assess the quality of the proof based on the following criteria:\begin{enumerate}\item \textbf{Faults:} Formalizations that contain bugs, e.g. proofs that contain logical errors, undefined functions, or undefined symbols.\item \textbf{Performance:} Formalizations that are slow and take longer to verify than similar formalizations.\item \textbf{Understandability:} Formalizations that are easy to read.\item \textbf{Maintainability:} Formalizations that require little maintenance.\item \textbf{Simplicity:} Formalizations that are simple and easy to use.\item \textbf{Uniformity:} Formalizations that are uniform, i.e. use the same programming style and logic, and avoid use of different kinds of annotations.\item \textbf
3:\begin{itemize}\item It is not very readable. We can't see the forest for the trees.\item It is hard to understand, especially if you have not seen the full formalization yet. It contains a lot of abbreviations that are not explained yet.\item It is not very maintainable. Every time a change is made to a function, the entire thing has to be re-formalized.\end{itemize}We can now extend the formalization by adding the following snippet:\begin{code}abbreviation (input) newmerge_view_data :: "view_data\<^sub>m newmerge" where  "(view_data, view_data) blindable\<^sub>m \<Rightarrow> (view_data, view_data) blindable\<^sub>m \<Rightarrow> (view_data, view_data) blindable\<^sub>m optionnewmerge_view_data \<equiv> (view_data \<Rightarrow> view_data) \<Rightarrow> (view_data \<Rightarrow> view_data \<Rightarrow> view_data option) \<Rightarrow> (view_data, view_data)
7.\end{example}This example is not at all uncommon, so we can formalize a rule-of-thumb as follows:\begin{rule}\label{rule_of_thumb}The quality of a formalization is the product of correctness, understandability, maintainability, and ease-of-use.\end{rule}In Isabelle, we can easily assess the correctness of a formalization using the :is_correct tactic. But what about the other three qualities?\begin{question}\label{quality_of_formalization}How do we assess the other three qualities of a formalization?\end{question}As we will see later, we can formally define these three qualities.\subsection{Understandability}\label{understandability}Ideally, a formalization should be understandable. It should be clear and concise.What do we mean by understandability? In essence, we need to be able to \emph{read} the formalization, and understand what we are reading.If we can
5.'''-- A partial answer to the question, perhaps not the most complete one, but a good start./** * * The basic idea is that the quality of a proof is rated by the following quality metrics: *  * understandability: Can we understand the proof in a few seconds? *  * maintainability: Are we going to be able to make changes to this proof in the future? *  * usefulness: Is this proof going to be useful? *  * correctness: Are we confident that the proof is correct? *  * testability: Can we verify the correctness of this proof? *  * modularity: Can we split this proof into modules and reuse them? *  * goodness: Is this proof readable? *  * extendability: Are we able to easily extend this proof? * * The quality of a proof is then rated by a number of factors. * * We then use the quality metrics to create a score for the quality of a proof. * * A proof is considered of low quality if: * * - The proof is of low understandability.
3. What makes it bad?\begin{itemize}\item The definition of \texttt{to\_view\<^sub>h} is not complete, the missing definitions are just ellipses.\item The formalization is not clear: \texttt{h} is not introduced anywhere and it is not clear where \texttt{view\<^sub>h'} comes from.\item The definition is too general: we don't know anything about the type \texttt{view\<^sub>h}. This kind of generality is quite common, but it is not good practice to do that.\end{itemize}With the power of Isabelle, we can, in principle, overcome these weaknesses:\begin{itemize}\item We can use the \texttt{verbatim} tactic to introduce a \texttt{h} parameter, and as a consequence, to define \texttt{view\<^sub>h'}.\item We can use the \texttt{shorthand} tactic to make the type \texttt{view\<^sub>h} more specific.\item We can use the \texttt{independent} tactic to make a definition more general
3. It could be improved by making the definitions more explicit and the proofs easier to read.A second example can be found below.\begin{verbatim}lemma from_to_view\<^sub>h [simp]: "view\<^sub>h \<Rightarrow> (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>hfrom_view\<^sub>h ((view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>h \<Rightarrow> view\<^sub>hto_view\<^sub>h (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>hx) = (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>hx"  by (auto simp: blindable\<^sub>h.map_comp o_def prod.map_comp)\end{verbatim}This has a 10 for clarity and understanding and a
7. The definitions are understandable. I would still have to spend some time understanding the proof though.Some definitions are not as clear. Consider the following definition:lemma cr_view_body_Grp: "(view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>h \<Rightarrow> view\<^sub>h \<Rightarrow> boolGrp (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>h setUNIV (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>h \<Rightarrow> view\<^sub>h \<Rightarrow> boolGrp (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>h setUNIV (view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>h"  by(simp add: cr_view_def Grp_def fun_eq_iff)(transfer
3.It is rather hard to understand and there is a lot of duplication.The difficulty to understand it comes from the fact that the author has made use of a number of definitional lemma.This particular fragment is from Isabelle/HOL model of the Coq standard library, the proof of [std_list_rel_Grp].It is a rather complex fragment, probably the complex part of the library.I don't want to blame the author, it is just an example.The code is complicated and hard to maintain and it is not clear why the author has used a specific set of definitions in particular order.If we have a few thousands of such fragments, it is very hard to maintain them, especially if the definitions and lemmas are written by different authors.A particular problem is that when the library is extended with new lemmas, it is necessary to update all the fragments that use them.We have a few proposals to make formalizations more usable and maintainable.\subsection{Introduce a grammar}This idea is similar to the idea of introducing a type syntax for defining new types in HOL.We
5, which is acceptable, but I would give it a 6 or 7 if I had the time.Consider the following snippet:primrec to_view\<^sub>m :: "view\<^sub>m' \<Rightarrow> view\<^sub>m" where  from_view :: "view\<^sub>m' \<Rightarrow> view\<^sub>m"  apply (induct_on view)  unfolding from_view_defendThis is a poor formalization, and it is not even correct! However, a formalization of this quality will be given the same score as the first snippet.Some formalizations are also bad in a different sense. They are low-quality, but there is a large chance that they are correct.This is a serious problem as we might be wrongly convinced that a formalization is correct, when in reality it is wrong.\section{Demonstrating quality}In the absence of a formal method to assess the quality of a formalization, we need to demonstrate it manually.This should be possible by using tools that are available in Isabelle/HOL, and that will be described below.
3.On the other hand, the following snippet is very easy to read, well understood, and has a clear proof:lemma from_to_view_m [simp]: "view_m \<Rightarrow> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m, view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>mfrom_view_m (((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m, view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>m \<Rightarrow> view_mto_view_m ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m, view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>mx) = ((
3.Apart from these missing definitions and lemmas, the proof is a bit too verbose. In the following proof, we can simplify some of the steps:apply(induction view\<^sub>mx)  apply(simp add: blindable\<^sub>m.map_comp[symmetric] o_def prod.map_comp[symmetric] list.map_comp[symmetric] add: blindable\<^sub>m.map_id[unfolded id_def])  doneendWhat happens here is that we have a case for every element in the vector, and we apply a lemma which applies to the whole vector. We can simplify this as follows:apply(induction view\<^sub>mx)  apply(simp add: blindable\<^sub>m.map_comp[symmetric] o_def prod.map_comp[symmetric] list.map_comp[symmetric] add: blindable\<^sub>m.map_id[unfolded id_def])  doneendThe intuition is that we can use a lemma once for the whole vector, and the case is then closed.
5. To improve it, we should document the assumptions that are being made. This would make it more understandable and maintainable. Also, I would prefer to have a proof of correctness for this, so we could have a 6. The proof would be short but useful.\end{example}In the following, we take a look at a more complex example.\begin{example}[Code]{\lstset{basicstyle=\scriptsize,columns=fullflexible,xleftmargin=2em,linenumberstyle=\tiny,aboveskip=0pt,belowskip=0pt,numberstyle=\tiny,morekeywords={set},keywordstyle=\color{blue},escapeinside={\%},keywordstyle=\color{magenta},aboveskip=0pt,belowskip=0pt,numberstyle=\tiny,morekeywords={view},keywordstyle=\color{cyan},aboveskip=0pt,belowskip=0pt,numberstyle=\tiny,morekeywords={type},keywordstyle=\color{magenta},ab
6.The definition of `lifting_syntax` is not well-written. It should be understood from the context, but if this were in a formal paper, it would be good to write it more clearly.The `transfer_rule` lemma should also be more clearly written. The proof is quite technical and the user of the formalization should be able to understand it. It would be beneficial to have an informal proof, that the user can follow, alongside the formal proof.The lemma `includes lifting_syntax` is a little misleading, as it is not clear that it is a subset of `lifting_syntax`. It would be good to have a name for the subset that emphasizes this.To improve the quality of the formalization, the following changes should be made:\begin{itemize}\item Define the subset `includes lifting_syntax` explicitly.\item Write a more informal proof for `transfer_rule`.\end{itemize}Let us take the following snippet as an example:\begin{code}lemma View\<^sub>m_transfer [transfer_rule]: includes lifting_syntax
3.The first point of improvement is the lack of comments.The second point is that we would like the authors to explicitly write the definition of \c view_merkle, so that they can be more precise about it and be confident that they're using it correctly.To put it in another way, the quality of this formalization is not bad, but it is not perfect.Now let us take the following snippet:code_datatype view_merklecontext begininterpretation view_merkle .abbreviation (input) hash_view_content :: "(view_content\<^sub>m, view_content\<^sub>h) hash" whereendlet  merkle_tree =    List.fold_left      (fun        (l, lv) r =>          (Hash.hash_view_content             l r             (Hash.hash_view_content              lv r              (Hash.hash_view_content               l r lv)              0))      (hash_view_content        (merge_views          (List.split_left
10.\end{blockquote}\strong{Answer}The answer is that it is possible to construct a theory such that for any predicate \strong{P} that is valid for the theory, a formalization in Isabelle/HOL can be found such that \strong{P} is also valid in Isabelle/HOL.\strong{Reasoning}Consider some predicate \strong{P} and a formalization \em{P'}. \strong{P} is valid in the formalization \em{P'} if, and only if, there exists a proof \em{p} for \strong{P} in \em{P'}, such that\begin{blockquote}\begin{itemize}  \item \em{p} is of the form\begin{itemize}  \item `==>` `P`, and  \item `==>` `p1`, `p2` ... `p_n`, with \em{p1} ... \em{p_n} being `==>`-eliminable sub-proofs for \strong{P}, and  \item `==
5.\section{Evaluation}The tooling in Isabelle/HOL adds a new dimension of complexity to formal verification. The following evaluation aims to capture the impact of Isabelle/HOL's powerful tooling on the formal verification of industrial-strength software.\subsection{Methodology}This evaluation has the following aim:\begin{itemize}\item \textbf{Verification of Isabelle proofs} - To understand the effort required to verify Isabelle proofs.\item \textbf{Different methods of proof verification} - To evaluate the benefits of Isabelle's powerful proof engine.\item \textbf{Pull requests} - To analyze the impact of Isabelle/HOL's powerful tooling on the efficiency of pull requests.\end{itemize}The evaluation will focus on three Isabelle/HOL projects that have an industrial use:\begin{itemize}\item \textbf{Isabelle/HOL Core} - The library that contains Isabelle's proof engine.\item \textbf{Isabelle/HOL Theory} - The library that contains Isabelle's rich
1.This definition is not good, but not bad either. We have defined a predicate `merge_view`, which is part of the `merge` module, and the definition assumes that `view` is a "merge view". It does not define what this means, so it is hard to understand what is going on. The definition also requires a big lemma to prove that merging two views yields a merge view.This definition is bad, but it does not break the proof. The proof is still correct, as the proof of this lemma does not depend on the definition.\begin{quote}If you have to use `merge_view` in other proofs, you might have to prove the lemma again, which is a pain.\end{quote}We should have the following definition instead:.lift_definition merge_view :: "view\<^sub>m merge" is  fun (t1, t2 : 'a) {_} => view t1 \<turnstile> view t2endThis definition is much better. It is clear what a merge view is, and it does not require a big lemma. We can just use the
7.\end{blockquote}I would give it a \strong{5} because the quality is \strong{not} "exceptional".What are the other "scales" that I could use in these types of situations?Comment: The question is way too broad and too subjective to be answered by a good answer. Maybe you could clarify what you are looking for and give us more context?Comment: @Raphael I am looking for a more in depth answer. I have edited my question to give more context.Comment: I'm not sure what you're asking for. You want to know how to *measure* the quality? But you don't have any *measure* in mind, so how would it be possible to discuss this? Or are you asking for some *subjective* way of assessing it? In that case, you can't have a general answer, it's all subjective and depends on what you consider to be good and bad.Comment: @Raphael I am asking for a more in depth answer. I have edited my question to give more context.Comment: I'm not sure I
6.The code is pretty clear as it uses standard Isabelle symbols for things like "view" and "map_comp". However, it is difficult to follow as it is rather long. Also, when checking the proof, it is hard to tell where it goes wrong. If we try to run the proof in Coq, we get the following error:\begin{code}<error: unbound variable blinding_of_view_iff>\end{code}In this case, we would say that it is not understandable as it is too hard to follow.\section{Maintainability}The code can be improved in various ways to make it more maintainable.We can improve the readability of the code by breaking it up into smaller snippets. In this case, we can break it up into two separate snippets as follows:\begin{code}lemma blinding_of_view_iff' [simp]:  "view\<^sub>m \<Rightarrow> view\<^sub>m \<Rightarrow> boolblinding_of_view ((((view_metadata, view_metadata) blindable\<^sub>m
5.\end{blockquote}\strong{Summary:}Isabelle is not a proof checker. It is a theorem prover that also proves theorems on top of formalizations. The formalization quality is very important for Isabelle.Comment: Thank you for your comments.  I think I have now understood the difference between `IMPLIES` and `ASSUMES`.  I have now edited my post to remove all `IMPLIES` statements and added `ASSUMES` statements in their place.  I have also added the `assumes` and `induction` attributes.  I am now looking at adding `definition` statements.  I have now added a few `definition` statements.Comment: You are now on the right track. I hope you will soon have a pretty good formalization.
2.The purpose of this talk is to explain what a good formalization looks like.The talk has two parts.\begin{itemize}\item The first part introduces the requirements that must be fulfilled in order to be able to have a good formalization.\item The second part explains what a good Isabelle formalization looks like.\end{itemize}I will be using the Isabelle formalization of \cite{FM18} for the examples.\section{First part}The requirements that must be fulfilled in order to have a good formalization are the following:\begin{itemize}\item The formalization must be understandable.\item The formalization must be maintainable.\item The formalization must be easy to use.\end{itemize}Understandability is subjective and subject to different opinions. However, there are certain criteria that are usually considered acceptable.\begin{itemize}\item A good formalization is well defined.\item A good formalization has a clear structure.\item A good formalization has easy to read proofs.\item A good formalization
9.Now let us take the following snippet:type_abbreviation transaction_id_to_tran_id = "transaction_id \<Rightarrow> transaction"type_abbreviation transaction_id_to_tran_id_of_type_map = "(type map, type map) hashable_map"abbreviation (input) transaction_id_to_tran_id_of_type_map :: "(transaction_id, (view list, common_metadata, participant_metadata) list) hashable_map" where  "(view list, common_metadata, participant_metadata) \<Rightarrow> (view list, common_metadata, participant_metadata) list \<Rightarrow> transaction_id \<Rightarrow> (view list, common_metadata, participant_metadata) list" \<equiv>  "view \<Rightarrow> common_metadata \<Rightarrow> participant_metadata \<Rightarrow> (view list, common_metadata, participant_metadata) list"We can see that the quality is not good: The abbreviation is confusing, the definition uses an unmentioned function, and it is unclear how the type class (
3.This is the definition of the type "common_metadata\<^sub>m merge" from the paper \cite{MEL03}.The type of "hash_participant_metadata" is not defined in the paper but it is part of the Isabelle definition.The example in \cite{MEL03} defines the type of the common metadata for the merge. The "merge" keyword indicates that the definition is actually for the "merge" function.The "merge" function is defined in the following:abbreviation (input) merge :: "('a \<Rightarrow> 'a option) \<Rightarrow> ('a \<Rightarrow> 'a option) \<Rightarrow> ('a \<Rightarrow> 'a option) option" where  "merge a1 a2 \<equiv> (a1 \<and> a2) option \<or> (a1 \<and> a2) option"\begin{lstlisting}abbreviation (input) merge_common_metadata :: "common_metadata\<^sub>m merge" where  "(common_metadata, common_metadata) blindable\<^sub>m \<Rightarrow> (common_metadata,
4 or 5.The proof of this snippet is also reasonable. Let us take the following example of a proof that is too hard to follow.abbreviation (input) initialize_transactions :: "('a, 'b) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool option" where  "initialize_transactions key where key \<in> 'a \<Longrightarrow>   key \<in> 'b \<Longrightarrow> (key, key) \<in> 'a \<Longrightarrow> key \<in> 'b \<Longrightarrow>   (key, key) \<in> 'a \<Longrightarrow> key \<in> 'b \<Longrightarrow>   (key, key) \<in> 'a \<Longrightarrow> key \<in> 'b \<Longrightarrow>   (key, key) \<in> 'a \<Longrightarrow> key \<in> 'b \<Longrightarrow>   (key, key) \<in> 'a \<Longrightarrow> key \<in> 'b \<Longrightarrow>   (key, key) \<in> 'a \<Longrightarrow> key \<in> 'b \<Longrightarrow>   (key, key) \<in> 'a \<Longrightarrow> key
7.To improve the quality, we need to take a closer look at the Isabelle proof:\begin{pre}lemma Transaction\<^sub>h_transfer [transfer_rule]: includes lifting_syntax  "((=) ===> ((common_metadata blindable\<^sub>h \<times> participant_metadata blindable\<^sub>h) \<times> view\<^sub>h list) blindable\<^sub>h \<Rightarrow> transaction\<^sub>h \<Rightarrow> boolpcr_transaction\<^sub>h) ((common_metadata blindable\<^sub>h \<times> participant_metadata blindable\<^sub>h) \<times> view\<^sub>h list) blindable\<^sub>h \<Rightarrow> ((common_metadata blindable\<^sub>h \<times> participant_metadata blindable\<^sub>h) \<times> view\<^sub>h list) blindable\<^sub>hid ((common_metadata blindable\<^sub>h \<times> participant_metadata blindable\<^sub>h) \<times> view\<^sub>h list) blindable\<^sub>h \<Rightarrow> transaction\<^sub>hTransaction\<^sub
3.Now imagine this is the body of a definition of the base of a large proof.Let us assume this definition is in a file `base.v`. We can add some comments, maybe even fix some typos, add some definitions, and even add some new theorems. All these changes are meant to improve the quality of the definition, and if I get everything right, I can always trust that it is correct.This works fine when we are working on the definition itself. However, when it is time to read the definition, there is no way for me to verify that all these improvements have not broken something.This is where a version control system like Git comes into play.\subsection{Git}Git is an open source version control system.It allows us to have a record of all the changes we have made to our Isabelle definitions.This way, if we forget to add a definition, or change the definition of a lemma, we can easily track down the previous definition.Also, we can track the time we made a change to the definition, and see what changes came first and what came after.These features are more useful when
10 for correctness and perhaps a 1.5 for comprehensibility.The following snippet, on the other hand, would get a 10 for correctness and 100 for comprehensibility:code_datatype (a \<times> (b \<times> c) \<times> d) (a \<times> (b \<times> c) \<times> d)context begininterpretation transaction_merkle .lift_definition a_hash :: "transaction\<^sub>m" hashlift_definition b_hash :: "transaction\<^sub>m" hashlift_definition c_hash :: "transaction\<^sub>m" hashlift_definition d_hash :: "transaction\<^sub>m" hashlift_definition a_hash_is :: "transaction\<^sub>h" hashlift_definition b_hash_is :: "transaction\<^sub>h" hashlift_definition c_hash_is :: "transaction\<^sub>h" hashlift_definition d_hash_is :: "transaction\<^sub>h" hashlift_definition a_hash_
5:\begin{itemize}\item 1: It does what it's supposed to, but is very hard to follow.\item 2: It does what it's supposed to, but only a few people can follow it.\item 3: It does what it's supposed to, but it's not very efficient.\item 4: It does what it's supposed to, and it's pretty efficient.\item 5: It does what it's supposed to, and it's easy to follow and efficient.\item 6: It does what it's supposed to, and it's pretty easy to follow.\item 7: It does what it's supposed to, and it's easy to follow.\item 8: It does what it's supposed to, and it's easy to follow and efficient.\item 9: It does what it's supposed to, and it's easy to follow and it's efficient.\item 10: It does what it's supposed to, and it's easy to follow and efficient and it doesn't use any
1 or 2.It has the following shortcomings:\begin{itemize}\item The syntax is cluttered: \em{``transaction\<^sub>m merge''} means the same as \em{``transaction merge''}, however the first one is less common.\item The definition name \em{merge_transaction} is confusing.\end{itemize}\section{What can be done?}I propose that there are three things we can do to improve the quality of the code:\begin{itemize}\item Fix the syntax: Make the definition \em{merge_transaction} as we do in Isabelle/HOL\item Rewrite the definition: It can be done in a way that is both readable and correct, and that does not break the original code.\end{itemize}\section{How can we do it?}Ideally, we would use [Purely Functional Data Types](https://wiki.haskell.org/Purely_functional_data_types), a subset of Haskell with [Linear Types](https://wiki.haskell.org/Linear_types), which
10.Ideally the definition of "view_merkle" should be abstracted away from the actual proof, and put into a separate file. In practice, that is not always possible, as the context for proofs is often complex, and unavoidably makes use of the definition.Here the proof "merkle_interface" is split in two parts. The part that defines the interface is not necessarily abstracted, as it is used in many proofs and is used in other contexts. The part that actually proves the definition is transferred to the context file.The proof transfer actually consists of a simple transformation that takes a context, and creates an Isabelle proof. The proof can be consumed by Isabelle and used for checking.### Usage### ExampleLet us take a closer look at the transfer of the proof for the merkle interface.Let us assume that we have already imported the context definition "merkle_interface" into our Isabelle session.```lemma merkle_interface:  "(transaction\<^sub>m \<Rightarrow> transaction\<^sub>m \<Rightarrow> bool) \<Rightarrow> (transaction\<^sub>m
4.So, we can say that the Isabelle proof of the given snippet is correct, but we would say that it is not yet of good quality.There are several ways to improve the quality.Let us take the example above and apply some of these techniques.The first thing we do is adding a comment that explains the snippet.The next thing we do is add definitions for the missing lemmas andlet theorems.If we add the definitions and theorems to the snippet, it looks like this:\begin{verbatim}(* The following definitions are missing *)definition from_view :: "view \<Rightarrow> view'" where  "view \<Rightarrow> (view_metadata \<times> view_data) rose_treefrom_view (view_metadata \<Rightarrow> view_data \<Rightarrow> view list \<Rightarrow> viewView view_metadatavm view_datavd view listvs) = (view_metadata \<times> view_data) \<times> (view_metadata \<times> view_data) rose_tree list \<Rightarrow> (view_metadata \<times> view_data) rose
10.\end{example}\begin{definition}[Ranking]Let $T$ be an Isabelle/HOL theory. A predicate $p$ is \emph{correct} in $T$ iff the theorem $p$ holds in $T$. A predicate $p$ is \emph{verified} in $T$ iff $\forall p'.\mathit{view}(p')$ is correct in $T$. We say that a theorem is \emph{complete} in $T$ iff it is verified in $T$.\end{definition}\begin{definition}[Nesting]Let $T$ be an Isabelle/HOL theory. A theory $T'$ is \emph{nested} in $T$ iff there exists a set $\mathcal{T}'$ of \emph{internal} theories such that $T' \subseteq \bigcup \mathcal{T}'$ and $\forall T \in \mathcal{T}'$.\end{definition}\begin{example}The following code is nested:\begin{lstlisting}definition f := (S :: nat | 0).
2, as some of the statements are hard to follow, some are redundant and the proof for the lemma is far from minimal.Here is a more comprehensive formalization that does not have these issues.\begin{code}namespace cr_view_vw  imports Grp  imports View  imports cr_view_vw_Grp  assumes Grp_def: "Grp rose_tree \<Rightarrow> rose_tree \<Rightarrow> boolGrp rose_tree setUNIV rose_tree setUNIV rose_tree \<Rightarrow> rose_tree"  assumes cr_view_def: "cr_view rose_tree setUNIV rose_tree setUNIV rose_tree \<Rightarrow> rose_tree"  assumes view_def: "View rose_tree setUNIV rose_tree setUNIV rose_tree \<Rightarrow> rose_tree"  assumes cr_view_Grp_def: "cr_view_Grp rose_tree setUNIV rose_tree setUNIV rose_tree \<Rightarrow> rose_tree"  assumes view_Grp_def: "View_Grp rose_tree setUNIV rose
9.However, if we slightly change it, the whole meaning of the program is lost.\begin{code}definition view_content (v_md : view_metadata) (v_d : view_data) (vc : view_content) : (view_metadata, view_metadata) blindable\<^sub>m :: "('a, 'a) list \<Rightarrow> 'a list" :=  { [[v_md, v_d]] (vc : view_content) }definition embed_view_content (v_md : view_metadata) (v_d : view_data) (vc : view_content) : view_metadata \<times> view_data \<Rightarrow> (view_metadata, view_metadata) blindable\<^sub>m :: "('a, 'a) list \<Rightarrow> 'a list" :=  { (v_md, v_d) \<Rightarrow>    (v_d, v_d) \<Rightarrow> (vc : view_content) \<Rightarrow>    [[v_md, v_d]] (vc : view_content) }definition map_prod_view_
5.Let us now look at a definition which is less clear:lemma "x \<le> y \<and> x \<le> z \<and> y \<le> x \<and> y \<le> z \<and> z \<le> x \<and> z \<le> y \<and> x \<le> z \<and> y \<le> z \<and> z \<le> y \<and> z \<le> x \<and> y \<le> x \<and> y \<le> z \<and> z \<le> x \<and> z \<le> y \<and> x \<le> z \<and> y \<le> z \<and> z \<le> y \<and> z \<le> x \<and> y \<le> z \<and> z \<le> y \<and> z \<le> x \<and> y \<le> z \<and> z \<le> y \<and> z \<le> x \<and> y \<le> z \<and> z \<le> y \<and> z \<le> x \<and> y \<le> z \<and> z \<le> y \<and> z \<le>
4.For a complete Isabelle/HOL specification, there are many more things to be aware of, such as\begin{itemize}\item The overall structure of the specification and the logical structure of the proofs.\item The formalization should be understandable.\item Proofs should be short and easy to follow.\item The proofs should be correct.\end{itemize}\subsection{Tools}Isabelle has two different tools for the formalization of security protocols:\begin{itemize}\item \textbf{Decorator:} The decorator introduces the notion of global objects that are used throughout the specification. It also introduces the notion of protocol operations and proofs.\item \textbf{Strategy:} The strategy introduces the notion of strategic protocol operations and proofs.\end{itemize}The two tools work together for the formalization of security protocols. This is done by the user providing proof strategies for protocol operations in the decorator tool and then using these strategies in the strategy tool.\subsection{Typical use cases}\begin{itemize}\item \textbf{
5 or 6.It should be noted that the only way to improve the quality of this formalization is to make it more explicit. In other words, if we are not sure about the quality of the formalization, then it is time to make it more explicit. This will make it easier to understand and maintain.Because of this, we should only formalize the things that we are sure about.This is the way we did it in the first version of [1].We did not formalize everything we wanted.For example, we omitted the formalization of an accessor for each field of the common metadata and the participant metadata, to keep the size of the formalization manageable.\begin{code}context Transactiondefinition  iso_transaction :: "((common_metadata \<times> participant_metadata) \<times> view list) \<Rightarrow> ((common_metadata \<times> participant_metadata) \<times> view list) set \<Rightarrow> booltype_definition transaction \<Rightarrow> (common_metadata \<times> participant_metadata) \<times> view listthe_Transaction (common_metadata \<times> participant_metadata
4.If this code is now improved in such a way that we move the (common_metadata \<Rightarrow> participant_metadata) into the parameter list, it no longer works. It is still correct, but the quality of the formalization has been reduced.Here is the improved definition:.lift_definition embed_transaction :: "transaction \<Rightarrow> transaction\<^sub>m" is  "(('a, 'b) blindable\<^sub>m \<times> ('c, 'd) blindable\<^sub>m) \<times> view\<^sub>m list \<Rightarrow> (view list \<Rightarrow> view\<^sub>m list) \<Rightarrow> ('a \<times> 'c) \<times> view list \<Rightarrow> (('a, 'b) blindable\<^sub>m \<times> ('c, 'd) blindable\<^sub>m) \<times> view\<^sub>m listmap_prod (('a \<Rightarrow> ('a, 'b) blindable\<^sub>m) \<Rightarrow> ('c \<Rightarrow> ('c, 'd) blindable\<^sub>m) \<Rightarrow> 'a \<times> 'c \<
7.\section{Interactive Proof}\subsection{Theorem proving}\subsubsection{Sugar and proof tactics}Proofs are written in \texttt{Ltac} and in the same style as proofs written in Isabelle. A proof tactic is a set of \texttt{Ltac} clauses that can be used to prove a goal. Tactics are usually grouped by subject (like \texttt{end} or \texttt{invariant} for example). A proof can be ``driven'' by a proof tactic, as in Isabelle, which gives us the ability to easily create and reuse proof tactics.The sugar function is a proof tactic that allows to prove the validity of an assertion of the form \texttt{Assertion}. It is very similar to the \texttt{Ltac} \texttt{assumption} tactic that is available in Isabelle. The sugar \texttt{Assertion} tactic is defined as:\begin{verbatim}sugar :: "proof \<Rightarrow> proof" where  sugar (proof p):=    let P \<equiv> assert (is_v:_\<
7.\end{code}Answer: \begin{itemize}\item The reasoning about the `boolblinding_of_view` function is a bit more complicated than necessary.  It could be made more concise and readable if the lemmas were a little simpler.\item `boolblinding_of_view` is defined recursively on both its inputs and its output, which may or may not be a good idea.  You should consider making it a meta-function.\item The `view_zipper` function is defined in terms of an `update_view`, which can be called recursively on its input.  This seems like a very good place for the function to be defined meta-functionally.\end{itemize}So, you should probably write the definitions something like this:\begin{code}lemma blinding_of_mediator_view':  fixes viewview::"list list list" and view::"list"  shows    "view\<^sub>m \<Rightarrow> view\<^sub>m \<Rightarrow> boolblinding_of_view (view \<Rightarrow> view\<^sub>mmediator_
1.\section{Assessing the Quality of a Formalization}There are two steps to assessing the quality of a formalization:\begin{itemize}\item \textbf{Checking completeness:}\begin{itemize}\item \textbf{Checking the completeness of the definitions:} are there any definitions that are not used?\item \textbf{Checking the completeness of the lemmas:} are there any lemmas that are not used?\end{itemize}\item \textbf{Checking correctness:}\begin{itemize}\item \textbf{Checking the correctness of the lemmas:} are all the lemmas correct?\item \textbf{Checking the correctness of the proofs:}\begin{itemize}\item \textbf{Checking the correctness of the lemmas:} are all the lemmas correct?\item \textbf{Checking the correctness of the proofs:}\begin{itemize}\item \textbf{Checking the correctness of the lemmas:} are all the lemmas correct?\item
2.\newpageThe following snippet is better and has a score of 5:.lift_definition blind_view_path :: "view_path \<Rightarrow> view_path\<^sub>m" isdefinition view_path_lift :: "view_path \<Rightarrow> view_path\<^sub>m" is "\<lambda> (a,b,t) . (view_path (a,b,t), view_path (a,b,t))\<^rsub>m"end\newpageIf we want to assess the quality of the formalization in Isabelle/HOL, we can do this with the \texttt{isabelle/QE} tool.This tool offers a number of metrics to assess the quality of a formalization.The metrics are computed from the source code, not from the proof.The available metrics are:\begin{enumerate}\item \textbf{Complexity}: number of tokens, number of lines\item \textbf{Block-size}: average length of definitions\item \textbf{Overall}: overall score for the quality of the formalization
2.Let us rewrite the snippet..lift_definition embed_view_path_elem :: "view_path_elem \<Rightarrow> view_path_elem\<^sub>m" is  "(view_metadata \<times> view_data \<Rightarrow> (view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m) \<Rightarrow> (view_metadata \<times> view_data) \<times> (view_metadata \<times> view_data) rose_tree list \<times> (view_metadata \<times> view_data) rose_tree list \<Rightarrow> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m) \<times> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m, 'a) rose_tree\<^sub>m list \<times> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data
5.Let us now take the following snippet as another example:.let hash_view_path_elem "view_path_elem\<^sub>m \<Rightarrow> (view_content\<^sub>h \<times> view\<^sub>h list \<times> view\<^sub>h list)"  "((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m \<Rightarrow> view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) \<Rightarrow> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m) \<times> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m, view_metadata blindable\<^sub>h \<times> view_data blindable\<^sub>h) rose_tree\<^sub>m list \<times> ((view_metadata, view_metadata) blindable\<^sub>m \<times> (view
9. It is easy to understand, easy to follow and is highly maintainable.******************************************************************************    Proof to be done    INDEX OF TYPE TYPES    --------------------    U: view_m    V: view_t    W: view_z    H: view_h    P: view_p    E: view_e    B: view_b    N: view_n    A: view_a    M: view_m    T: view_t    D: view_d    F: view_f    VV: view_vv    VC: view_vc    VVV: view_vvv    VVVC: view_vvvc    VCVC: view_vcvc    VCVCVC: view_vcvcvc    VCVCVCVC: view_vcvcvcvc    VVVVCVCVC: view_vvvvcvcvc    VVVVVVVVVVVVVVVVVVV
10, it is very clear and well commented.However, as the Isabelle documentation mentions, we should aim to make our formalizations as understandable as possible. They should be easy to write and test, and be easy to read and understand.\subsubsection{My Approach to Better Quality}I believe that a major factor affecting the quality of a formalization is the lack of documentation and examples. For a proof assistant like Isabelle, which is very powerful, being able to construct proofs is not enough. I believe that there is a need for more information about the tool and its potential.Isabelle comes with a very powerful formalization language. As I said before, it is quite expressive. However, this is not the reason why I believe that there is a need for documentation and examples, but the fact that the language is different from the English language and the logic we are used to. This is also the reason why, as a formalization beginner, I needed a lot of time to understand the language, before being able to write and read proofs.As a result of the differences between the language and the English language, it is easy to make mistakes in formalization. There are things
3.\section{What is wrong?}\begin{itemize}\item The proof is not too hard to follow\item It is understandable\item It is maintainable (as long as it is not used elsewhere)\item The result is correct\end{itemize}However:\begin{itemize}\item The code is hard to read. With only a few exceptions, the `view` type is not used again.\item This is not a function but a primitive recursive function. It would be hard to change it to a function later on.\item It is hard to change it, as all the parameters are `view`s.\item This is not a solution, this is a proof. While it is a correct proof, I would rather like to have a solution, which would be more useful.\end{itemize}\section{What do we want?}I would like to assess the quality of a formalization by a set of criteria. The assessment should be done automatically. One could set up a formalization as a contest. For each criteria, one can have a fixed number of points (e.g. 
3.We therefore consider three aspects of quality: understandability, maintainability, and usability.Understandability means that the formalization is easy to read. That means that one can immediately understand the intent of the formalization.Maintainability means that if a proof needs to be modified, it is easy to find the place in the formalization where that proof needs to be changed.Usability means that the formalization is easy to use. This is mostly about the design of the program structure, and is independent of the current proof.\subsection{Understandability}The goal of understandability is to have the reader understand what the formalization does and how it does it.This is not so easy to measure, but an important aspect of understandability is that the formalization is not \emph{too} formal. The formalization should provide some explanation for how the proof works. This explanation should be explicit in the formalization, and it should not be too hard to find.Some people prefer to do their proofs in a very high-level, almost pseudocode-like language. In this case, the formalization should be a clear translation of the pseudocode
2.There are three different perspectives on quality:\begin{itemize}\item Understandability:How easy is it to understand the formalization?\item Maintainability:How easy is it to extend the formalization with new proof obligations?\item Usability:How easy is it to reason with the formalization?\end{itemize}These three aspects are important. We cannot have a high score in any of them. However, we can find a balance between these three.For example, if we find it difficult to understand a formalization, we can try to fix the definitions and lemmas, and then reassess it. We can also use helpers, such as, [Ideal](https://isabelle.in.tum.de/Ideal/).Another approach is to work in a team. A formalization that is easy to understand will be more likely to be shared.Having lemmas that are hard to read is also a quality issue. One of the tools we use in Isabelle/HOL is, [Reverse](https://isabelle.in.
9. It is clear that the zipper used for iterating over a list will never lead to a total mess, as the zipper is guaranteed to terminate.However, it is not always so clear. We can make it clearer by providing a definition of the list structure that is used in the definition of the zipper.\begin{verbatim}context fixes participant :: participant begindefinition zipper :: "view \<Rightarrow> 'a list \<Rightarrow> 'a list \<Rightarrow> 'a list" where  "zipper viewtree_of_list (list_of_zipper, list_of_zipper) = (list_of_zipper, list_of_zipper)"enddefinition view_trees_for :: "view \<Rightarrow> view\<^sub>m list" where  "view \<Rightarrow> view\<^sub>m listview_trees_for viewview =   ((((view_metadata, view_metadata) blindable\<^sub>m \<times> (view_data, view_data) blindable\<^sub>m) \<times> view\<^sub>m list \<times> view\<^
5.\section{Quick's Formalization}The Formalization of this snippet using Quick's Formalization is:\begin{code}transaction_views_for T =  fun (common_metadata : transaction) (participant_metadata : participant_metadata) (views : transaction_view list)    =>    fun (common_metadata : transaction) (participant_metadata : participant_metadata) (views : transaction_view list)      =>      common_metadata, participant_metadata, viewsend\end{code}The full Formalization is:\begin{code}transaction_views_for T =  fun (common_metadata : transaction) (participant_metadata : participant_metadata) (views : transaction_view list)    =>    fun (common_metadata : transaction) (participant_metadata : participant_metadata) (views : transaction_view list)      =>      common_metadata, participant_metadata, viewsend\end{code}The Formalization has the following issues:
5, because I think it could be better.However, in a project where we are developing a new framework with a new language, the quality of the formalization is a factor we need to consider.Let us now move to Isabelle/HOL 2018.The HOL syntax has been substantially changed compared to Isabelle/HOL 2015.\begin{lstlisting}lemma view_trees_for_same_hash:  "view\<^sub>mvt \<in> view\<^sub>m list \<Rightarrow> view\<^sub>m setset (view \<Rightarrow> view\<^sub>m listview_trees_for viewview) \<Longrightarrow> view\<^sub>m \<Rightarrow> view\<^sub>hhash_view view\<^sub>mvt = view\<^sub>m \<Rightarrow> view\<^sub>hhash_view (view \<Rightarrow> view\<^sub>membed_view viewview)"\end{lstlisting}In HOL 2015, one would write:\begin{lstlisting}lemma view_trees_for_same_hash:  "
3.A common example of a simple mistake is to not use the simplified syntax of a definition. In this case, the lemma would have been defined as:lemma "transaction\<^sub>m \<Rightarrow> transaction\<^sub>hhash_transaction (transaction \<Rightarrow> transaction\<^sub>mtransaction_projection_for transactiont) = transaction\<^sub>m \<Rightarrow> transaction\<^sub>hhash_transaction (transaction \<Rightarrow> transaction\<^sub>membed_transaction transactiont)"proof-case "transaction \<Rightarrow> transaction\<^sub>m listtransaction_views_for transactiont = []"  case True thus "transaction\<^sub>m listtransaction_views_for transactiont = []"    by(simp add: transaction_projection_for_def Let_def hash_blind_transaction)next  case False  then have "transaction\<^sub>m set \<Rightarrow> transaction\<^sub>m optiontransaction.Merge (transaction\<^sub>m list \<Rightarrow> transaction\<^sub>m setset (transaction \<Rightarrow> transaction\<^sub>m listtransaction_views_for transactiont)) \<noteq> transaction\<^sub>m optionNone"
4.\end{code}This snippet is a proof that two transactions do not have the same hash. The proof can be found here: https://github.com/darcs/darcs-infrastructure/blob/master/darcs-core/isabelle/proofs/transaction_hash.thy. We can see that the proof is correct, but is it understandable?This can be improved by adding definitions and lemmas. It would also be good to give the name of the lemma. For example, `transaction_hash_sublist_defined` and `transaction_hash_sublist_eq_none` can be given to the proof.The definition of `transaction_hash_sublist` (given in the proof) can be copied as follows:\begin{code}lemma transaction_hash_sublist_defined:  assumes assms: "\<forall>i\<in>range A\<in>transaction\<^sub>m set. hash_of \<langle>A, i\<rangle> \<noteq> None"  shows "transaction_hash_sublist A (transaction\<^sub>m list) \<noteq> transaction
7.With this snippet as an example, the following questions may arise:\begin{itemize}\item What would be the best order of definitions and lemmas in a formalization?\item Which auxiliary definitions and lemmas should be included in the formalization?\item Which auxiliary definitions and lemmas should not be included in the formalization?\end{itemize}These are all questions that need to be answered by the user of the formalization.The formalization does \textit{not} need to be valid for all possible programs. It is sufficient to be valid for all simple programs and all programs that can be created from these programs by a finite sequence of calls to the primitive combinators. This is a weak version of the Curry-Howard correspondence.The author can provide hints and even code examples of programs, but cannot solve the user's problems for him.\subsubsection{Validity of the formalization}If we have a formalization of a program $P$, we want to know what consequences hold for all possible inputs. For that purpose we formulate the following definition:\begin{definition}[Validity
9.In real life, your Isabelle project will probably have many formalizations like this. The question then is: how do you assess the quality of a project?[1] Reusability and understandability--------The formalizations in this project are easy to understand. They are easy to reuse, and I can extend them. In the following section I will show how to use the tools described in this section to help you to improve the understandability of your formalizations.[2] Maintenance--------You want to be able to maintain the quality of your formalizations over time. After a long time you might want to update one of your formalizations to a more recent version of Isabelle/HOL. If this happens, you want to be able to easily update the formalizations in your project.[3] Easy to use--------Ideally, you want your formalizations to be easy to use. You want them to be easy to understand and to be easy to extend. This is the goal of the Isabelle/HOL development team, which has been working on tools that help you to achieve this goal.[4
7. The definition of optionSome is clumsy. Furthermore, the proof is actually a little tricky to follow. In a formal proof, we are trying to make the reader's task as easy as possible. I will say it again:When assessing the quality of an Isabelle formalization, we can always be totally assured that it is correct.However, quality can vary: Formalizations need to be understandable, maintainable, and easy to use.*)Definition "map" [intro] : "('a \<Rightarrow> 'b) \<Rightarrow> ('a list \<Rightarrow> 'b list)"  where "map f (as::'a list) = (a::'b list) | as= a"Definition "flat_map" [intro] : "('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a \<Rightarrow> 'b) \<Rightarrow> ('a list \<Rightarrow> 'b list)"  where "flat_map f g x0 (as::'a list) = flat_map g x (as@[x0])"Definition "bind_
5.(** The second formalization is somewhat better in terms of clarity and maintainability.This is still a simplistic example of a proof, but still much more readable than the first one.It is important to note that both of these formalizations are formally sound.*)(* begin hide *)(* WARNING: This page has been generated automatically.  *)(* Do not change it.  Page layout will be lost.  The page will be  *)(* recreated automatically the next time the file changes.  *)(* begin hide *)lemma omap_alt_None: "('b \<Rightarrow> 'a option) \<Rightarrow> 'b list \<Rightarrow> 'a list optionomap 'b \<Rightarrow> 'a optionf 'b listl = 'a list optionNone \<longleftrightarrow> (\<exists>'bx\<in>'b list \<Rightarrow> 'b \<Rightarrow> 'a optionf 'bx = 'a optionNone)"  by simplemma omap_nth: "\<lbrakk>('b \<Rightarrow> 'a option) \<Rightarrow> 'b list \<Rightarrow> 'a list optionomap 'b
3 (it could do with some proof simplification, and I am not sure whether the definition of listSome is fully correct).This simple example highlights a number of issues that may arise:\begin{enumerate}\item Formalization can be hard to read: The term 'optionf' is not explained in the definition, and the definition of 'listSome' is cumbersome.\item A formalization is not always correct: For example, if we assume that the definition of 'listSome' is not fully correct, then the lemma does not hold.\item The lemma is not so simple to understand: The proof is not very short. It relies on the metis command to apply the lemma for lists of different sizes, and it relies on the metis command \texttt{append\_Cons} for the induction step.\end{enumerate}\section{Isabelle 2014}The Isabelle 2014 report \cite{isabelle2014} describes the newest versions of Isabelle. The newest version is Isabelle 2017, but the report does not give details on what is new
6.Can we do better?\end{code}My main question is: \strong{is there a way to automatically assess the quality of an Isabelle formalization, given a library of patterns?}I want to perform this assessment on Isabelle's internal formalizations, as well as on user formalizations.Answer: \begin{blockquote}\strong{Is there a way to automatically assess the quality of an Isabelle formalization, given a library of patterns?}\end{blockquote}Isabelle's internal formalizations are split into two groups: those whose semantics is already defined by the user (at least in the sense of \em{knowing} the intended semantics of the definition), and those whose semantics is still defined in the process of formalization (at least in the sense of \em{dealing with} the semantics, and \em{hoping} it will make sense when finished).The former type is a subset of the latter type, and this is the kind of thing you can work with using Isabelle's \strong{`[pattern]`} tactic. This tactic matches and then instantiates patterns (e.
5.*Usability*Isabelle formalizations are easily usable, and it is often the case that we don't even need to look at the formalization to know what it does. With the example above, we immediately understand the meaning of the function and can use it with very little fuss.*Maintainability*Isabelle formalizations are easy to extend and understand. We don't need to look at code in order to understand how to extend it.With the example above, we immediately understand the meaning of the function and can use it with very little fuss.*Readability*Isabelle formalizations are easy to read. We don't need to have an understanding of programming languages or formal logic in order to understand them.With the example above, we immediately understand the meaning of the function and can use it with very little fuss.*Documentation*Isabelle formalizations are easy to document. With the example above, we immediately understand the meaning of the function and can use it with very little fuss.*Maintenance of Correctness*Isabelle formalizations
5. Why 5? Well, it is understandable, maintainable and not too hard to use, but it is far from perfect. In particular, we have the following problems:\begin{itemize}\item The definitions for _ and end are missing.\item The proof of the rule "isabelle_start_char" is missing.\item There is no proof of the property "isabelle_start_char".\end{itemize}I would prefer a formalization like the following, which is much better:\begin{code}lemma "isabelle_start_char" :begin  definition "isabelle_start_char" :  begin    definition "isabelle_start_char_alt" :    begin      definition "isabelle_start_char_alt_1" :      begin        definition "isabelle_start_char_alt_1_1" :        begin          definition "isabelle_start_char_alt_1_2" :          begin            definition "isabelle_start_char_alt_1_3" :
4, maybe 5.Is it even possible to get a better formalization with Isabelle?Answer: There are many factors that contribute to the quality of a formalization. Since Isabelle is a proof assistant and proof-checking is the most important part of it, I'll focus on the part of the quality that is about \em{proofs}, and the factors that are related to this.There are many factors that influence the readability of a formalization. I'll list some of them and mention some possible strategies to improve it. This is just a small selection and not exhaustive, but I hope it's a useful start.\begin{itemize}\item \strong{Structure of the proof}\begin{itemize}\item \em{Use good structures for the proof:} Isabelle has a good structure for a proof and supports many different ways to structure it. Many people try to avoid using it and mix everything together in one big proof. While it's not a big problem for small formalizations, it's a problem for big and complex ones. The proof looks less readable and does not make use of the tools that Isabelle provides.
4.The definition is clear, the pattern matching in the definition of "nat" is not trivial, but it is also not overwhelming. The proof is also clear, as is the correctness proof. But the definition of "wf_operator" is very complex and not very well named.### Type safetyFormalizations are checked to be type safe:functional_decomposition_invariant.v:   (nat option \<times> char list list \<Rightarrow> char list list \<Rightarrow> char list list)  (\<exists> (n,ss) \<in> (nat option \<times> char list list \<times> char list list).    (\<forall> (x,y) \<in> ss. x \<in> set (map nat (\<lambda>_. n)) \<and> y \<in> set (map (fun z. (char z) z) (\<lambda>_. ss)) \<and>       y \<in> set (map nat (\<lambda>_. n) ss)) \<and>      (\<forall> (x,y) \<in> ss. y \<in> set (map nat (\<lambda
7.5, since it is mostly clear, but some assumptions are not well written and, as said, the definitions are missing.However, not all formalizations are like this. Some are so unreadable that they are not usable at all. Others are so badly written that they are not correct (like the following snippet).definition "boolwell_formed \<equiv>       \<comment> \<open>Initial state\<close>      nat list \<Rightarrow> natlength nat listastI = natnumVars    \<and> (\<forall>natnatx<natnumVars. nat listastI!natx < nat \<Rightarrow> natnumVals natx)      \<comment> \<open>Goal\<close>    \<and> (nat \<times> nat) list \<Rightarrow> boolwf_partial_state (nat \<times> nat) listastG    \<comment> \<open>Operators\<close>    \<and> (char list list \<Rightarrow> booldistinct ((char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times>
5. It is a correct proof of an important part of the formalization, it is relatively clear. However, I would still like to be able to modify this proof in a way that does not break the formalization. As it stands, I need to make sure that the result of the proof is still correct (which can be difficult). More fundamentally, I would like to be able to implement the proof in Isabelle as a single proof that can be changed to add new assumptions or modify the proof.To put it simply, I would like to be able to add and edit assumptions in a way that is consistent with the Isabelle language. To do this, I would like to be able to edit the definitions of lemmas and theorems in a way that does not break the formalization. There should be a way to do this while making sure that the proof of the lemma still results in a correct and consistent formalization.Given the nature of the problem, it is natural to think that the solution lies in the standard Isabelle proof language and not in the Isabelle/HOL standard library. This is because Isabelle/HOL is very powerful and is usually used in a proof-based manner. The Isabel
5.Isabelle users have access to a number of different ways to assess the quality of an Isabelle formalization.- \textit{Performance} - Isabelle's \textit{metis} solver is optimized for proving correctness and is not suitable for proving performance, which is why \textit{z3} is available. However, if the formalization of a theorem that relies on performance cannot be proved with \textit{metis} solver, the \textit{metis} solver can still be used to \textit{explore} and \textit{visualize} the correctness of the formalization, which is more than can be said about most other theorem proving systems.- \textit{Maintainability} - The \textit{metis} solver is a bit slow, but that is the price to pay for being able to prove correctness with respect to the full language of Isabelle.- \textit{Understandability} - Isabelle's \textit{hide} command hides terms when they are not needed by the user. Annotation is used to add terms to the definition that the solver may need to see,
6.Isabelle's quality assurance mechanisms can be used to control the quality of formalizations.
2 or 3.Clearly, this definition needs more work.The best thing to do would be to fix it up first, make it understandable, and then move on to the next problem.If it is not clear how to improve the definition above, just set up a simple example using Isabelle’s programming language, \emph{Scala}. We can easily use Scala to define the new definition,\begin{code}import scala.reflect.ClassTagimport scala.reflect.runtime.{universe => u}import scala.language.implicitConversionsimport scala.language.{higherKinds, postfixOps}import scala.collection.immutable.Setdef lookup_operator (t : u.Type) =    t match {        case t: u.Type  if (u.classTag[u.Type].isAnnotation[u.AnnotationType[Boolean]]) =>            u.classTag[u.Type].select[Boolean].getAnnotation[u.AnnotationType[Boolean]].value        case t: u.Type  if (u.classTag[u.Type].isAnnotation[u
5.We can also look at this formalization from a different perspective. We can consider it as a program, an executable, and assess its quality that way. We can take the Isabelle formalization, transform it into a program (for example in the Isabelle-Vernacular language), and run it.For example, here is a program that produces the output<code>(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <b>2</b> <b>3</b>)(<b>1</b> <
6. Some definitions and lemmas are hard to follow and read. Some proofs are hard to follow and could break with any changes.What is a formalization that we would call a 'masterpiece'?\section{Questions}\begin{itemize}\item What are good criteria for assessing the quality of a formalization?\item What are good techniques for creating formalizations that are well-written and easy to follow?\item Is there any existing literature on this?\item Are there any existing guidelines?\item Are there any examples of good formalizations?\end{itemize}Comment: The short answer is that the quality of a formalization is what you think is good.  It is a personal opinion based on your own abilities and preferences.  Some people prefer formal proofs while others prefer clear diagrams with few lemmas and definitions.  I prefer diagrams but others prefer formal proofs.  I suspect that is what is going on here.Answer: \section{How to write correct formalizations}The best way to write correct formalizations is to be precise and consistent.  This means never using undefined symbols
5. It is understandable, maintainable, and easy to use.(*  context wf_ast_problem   begin          lemma I_valid: "nat \<Rightarrow> nat optionI \<in> (nat \<Rightarrow> nat option) setvalid_states"      using wf_initial       unfolding valid_states_def Dom_def I_def range_of_var_def      by (auto split:if_splits)          lemma lookup_operator_wf:      assumes "char list \<Rightarrow> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) optionlookup_operator char listname = char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat \<Rightarrow> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat
1 for understandability, and a 10 for maintainability.The proof is hard to follow, and the proof that it is correct requires a lot of metis-like magic. On the other hand, I can't easily see how I could improve the proof, without breaking it.This, to me, is not really a good example of formalization.Isabelle is a wonderful tool for writing proofs. But in order to use it properly, the formalization needs to be clean.(* Why is this such a problem? *)I'd like to be able to tell Isabelle to format my formalizations, so that they are easy to read and easy to maintain.(*This is not an unreasonable thing to ask.*)(*The proof tool in Isabelle is fantastic. However, it can be hard to follow proofs. Imagine a formalization like the following:\begin{code}lemma -  assume "distr (a \<times> b) (suc (\<lambda> n. a n b n)) = distr (a \<
7.The definitions and lemmas are difficult to follow. In addition, the following lemma is misleading:lemma execute_preserves_valid:  assumes "nat \<Rightarrow> nat options\<in>(nat \<Rightarrow> nat option) setvalid_states"  assumes "char list \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> boolenabled char listname nat \<Rightarrow> nat options"  assumes "char list \<Rightarrow> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat \<Rightarrow> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) optionSome (char listname',(nat \<times> nat) listpres,((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) listeffs,natcost)"  shows "char list \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> boolenabled
5.\end{blockquote}A similar snippet of code, but without the `auto` call, can be found [here](https://stackoverflow.com/a/52991996/849891).\begin{blockquote}Is there any way to prevent Isabelle from automatically generating code which is not of a good quality?\end{blockquote}Yes, one can disable the auto-generation of code. There is an [option](https://isabelle.in.tum.de/doc/isabelle_2021_3_2/isabelle_2021_3_2/options/option.html#option_splits_behavior) to control the behavior of `auto` in Isabelle's [options](https://isabelle.in.tum.de/doc/isabelle_2021_3_2/isabelle_2021_3_2/options/index.html) page.Here is a similar example, but without the `auto` call, of the quality of the code. The snippet is
5: understandable, and easy to use.Now, suppose we wanted to check whether this is an acceptable formalization. How would we go about it?How would we assess the understandability of the formalization?How would we assess the maintainability of the formalization?How would we assess the quality of the proof of the lemma?For the first one, we can probably use some automated tool. For the second one, I would do it manually. For the third one, I would look at the original proof in Isabelle/HOL and see whether it makes sense.This is tedious, time-consuming, and error-prone.This is why we have formalized version control systems, in which the formalization can be checked using formal methods.Our requirements for such a formalization checker are the following:\begin{itemize}\item \textit{Error Reporting:} The formalization checker must report all of the errors in the formalization.\item \textit{Formalization Checking:} The formalization checker must ensure that the formalization is correct.\item \textit{Formalization Conversion:}
5.Can you improve on this formalization? Maybe by adding a comment, by rephrasing the definition, or by refining it?""")        let proof = Proof(proofs[0], None, Some("""lemma map_add_map_of_fold:     fixes ps and m :: "type'a \<rightharpoonup> type'b"    assumes "'a list \<Rightarrow> booldistinct (('a \<times> 'b \<Rightarrow> 'a) \<Rightarrow> ('a \<times> 'b) list \<Rightarrow> 'a listmap 'a \<times> 'b \<Rightarrow> 'afst ('a \<times> 'b) listps)"    shows "'a \<Rightarrow> 'b optionm ++ ('a \<times> 'b) list \<Rightarrow> 'a \<Rightarrow> 'b optionmap_of ('a \<times> 'b) listps = ('a \<times> 'b \<Rightarrow> ('a \<Rightarrow> 'b option) \<Rightarrow> 'a \<Rightarrow> 'b option) \<Rightarrow> ('a \<times> 'b) list \<Rightarrow> ('a
4.#include "code"definition wf_code_thms :: "code"definition assms :: "assumptions"definition ast_problem :: "ast_problem"definition boolast_problem :: "boolast_problem"definition ast_precond :: "ast_precond list"definition state :: "state"definition ast_dom :: "ast_dom"definition ast_i :: "ast_i"definition ast_g :: "ast_g"definition wf_code_thms :: "wf_code_thms"definition assms :: "assumptions"definition ast_problem :: "ast_problem"definition boolast_problem :: "boolast_problem"definition ast_precond :: "ast_precond list"definition state :: "state"definition ast_dom :: "ast_dom"definition ast_i :: "ast_i"definition ast_g :: "ast_g"definition wf_code_thms :: "wf_code_thms"definition assms :: "assumptions"definition ast_problem :: "
4.Example (2):lemma match_implicit_pres_defs_v:    "\<And> x y m t f r s. \<And> e op \<in> \<inverse> c. (x, y) = op e \<and> (x, y) = op f \<and> (y, x) = op t \<and> (x, y) = op s \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r \<and> (y, x) = op r \<and> (x, y) = op r
2.(a) Unclear definitions: The definition of 'eff_enabled' is a bit hard to follow. It is not clear at first sight what 'nat' stands for, what 'nat options' stands for, and what the 'nat option execute opr' stands for. The definition of "'a \<times> 'b \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> 'c \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> nat \<Rightarrow> nat optionexecute_opr' \<equiv> \<lambda>('aname,'b_,((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) listeffs,'c_) nat \<Rightarrow> nat options" needs to be explained in a way that it is easy to understand what exactly is happening, what is the input, output, and what the parameters mean. It should be clear for the reader.(b) Proofs that are hard to follow: The proof of 'nat \<times> nat list \<Rightarrow> (nat \<times> nat) list \<Rightarrow> bool' should be easier to
6.The problem is that the name lookup_operator' is ambiguous. It can either be the lookup operator for a generic operator with the type name \<rightharpoonup> ast_operator or a lookup operator for the generic operator with the type name \<rightharpoonup> ast_problem.\begin{code}lemma lookup_operator' [simp]: "lookup_operator' P \<rightharpoonup> P = lookup_operator P"lemma lookup_operator_generic_eq [simp]: "lookup_operator' P \<rightharpoonup> P = lookup_operator P"\end{code}Both of these lemmas are true, but they are both useful. Having both of these is confusing and leads to a confusing formalization.This is an example of how a formalization is too weak.This example demonstrates how Isabelle formalizations can be too weak.What are the issues here?\begin{itemize}\item Isabelle formalizations cannot use generic names.\item The generic name lookup_operator' is ambiguous.\end{itemize}First, the
1 or 2.The problem is that the source code is hard to understand, in particular the `where` clause is hard to understand. It contains a `where` clause of its own, each of which contains a `where` clause of its own and so on.In addition, the `where` clauses are long. Even just this definition contains 100 lines of code, and it is not unusual for definitions to be more than 100 lines of code.Finally, the definition is hard to maintain. If a change is needed to `enabled' a different function must be called.Our example is bad because it is hard to understand, hard to maintain, and is likely to break with future changes.Hence, this is a bad example.We can improve this example as follows:\begin{code}definition enabled' :: "ast_problem \<Rightarrow> name \<Rightarrow> state \<Rightarrow> bool" where    "enabled' (char list \<times> nat option \<times> char list list) list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times>
2 or 3.My question is how can one go about improving the quality of such a formalization?I know the answer to this depends on the context, but I am particularly interested in the problem of having a formalization that is also a good design.Answer: From an Isabelle perspective, we could have done this better.\begin{code}definition execute' :: "ast_problem \<Rightarrow> name \<Rightarrow> state \<Rightarrow> state" where  "execute' (char list \<times> nat option \<times> char list list)    list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) list \<Rightarrow> char list \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> nat \<Rightarrow> nat option"lemma execute':  "execute' (char list \<times> nat option \<times> char list list)    list \<times> nat list \<times> (
5.Then we would like to improve the quality, e.g., by adding the missing definitions and lemmas, by giving more explanations, and by improving the proofs. Let us focus on the proof for the time being, because the other changes are just stylistic.The proof is confusing, but it is essentially correct. The crux is that the proof should prove that the three sets are disjoint. However, the proof currently shows that the three sets are disjoint only for a specific range of the first argument. We want to fix that.We assume that the domain of the first argument is in fact a set of natural numbers. For example, we could assume that the domain is [1,2,3,..]. Let us now try to fix the proof, but we do not yet know how to do that.First we need to fix the lemma. If we assume that the domain is a set of natural numbers, then the lemma matches our intuition. We can simply add that assumption.\begin{verbatim}lemma match_pres_correct:  assumes D: "(nat list \<Rightarrow> booldistinct ((nat \<times> nat \<
6 or so."""        )        try:            ct, trace = doctest.testmod(snippet, verbose=False)            if ct:                return ct        except Exception as e:            trace = trace.rstrip()            eprint("    !" + e.message + " in " + str(trace))            return False    if verbose:        for t in trace:            print(t)    if not verbose:        return Truedef test_isabelle_style(snippet):    if not doctest.testmod(snippet, verbose=False):        return False    else:        print("  OK in " + snippet)        return Truedef test_isabelle_style_doctest(snippet):    if not doctest.testmod(snippet, verbose=False):        return False    else:        print("  OK in " + snippet)        return Truedef test_isabelle_style_doctest_formalization
6. What could be improved?A simple way to get a higher quality is to use the 'proofs' keyword, making the proof of the lemma explicit:lemma enabled_opr'_correct:  assumes V: "nat \<Rightarrow> nat options\<in>(nat \<Rightarrow> nat option) setvalid_states"  assumes "char list \<Rightarrow> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) optionlookup_operator char listname = char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat \<Rightarrow> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) optionSome char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<
6.The main reason is that while Isabelle's theorem prover can prove most of the lemmas, it can't prove them as elegant and quickly as a human can.For example, the lemma [`nat \<times> nat` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list` `list
7.Isabelle's goal-level simplification system will produce a goal that is much simpler than this, for example:\begin{code}case \<open>(fields name pres effs)\<close> \<open>1\<close> \<open>((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat \<Rightarrow> bool) \<Rightarrow> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list\<close>  \<open>[[simp]]\<close> \<open>1\<close> \<open>((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat \<Rightarrow> bool) \<Rightarrow> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list\<close>  \<open>[[simp]]\<close> \<open>1\<close> \<open>((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat \<Rightarrow> bool) \<Rightarrow> ((nat \<times> nat) list \<times> nat \<times
3.This is a basic rule for formalizing an operation, and it is very clear.The problem is that a formalization is not only its rules, it is also its implementation.For example, looking at the definition of the apply function, one can see that it has an extra parameter (nat option), while it does not need it.This is the point where the code quality starts to deteriorate.What if the user wants to add some other properties to the operation?Does it break everything?This is why the second rule is important:\begin{blockquote}Reasoning about Formal Proofs - Relevance, Applicability and CompletenessA Formal Proof is Relevant if it is useful when building a proof.It is Applicable if it can be used in a proof.It is Complete if it covers all the relevant proof cases.\end{blockquote}The goal is to write a proof that is Relevant, Applicable and Complete.Relevance is only met if the formalization is correct, and it is not a property that one can have a priori.Applicability is
3.However, the following snippet is much better:have [simp]:         "((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> nat \<Rightarrow> nat option) \<Rightarrow> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> nat \<Rightarrow> nat optionfold (\<lambda>((nat \<times> nat) list_, natx, nat option_, natv) nat \<Rightarrow> nat options. nat \<Rightarrow> nat options(natx \<mapsto> natv)) ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) listl nat \<Rightarrow> nat options =         (nat \<times> nat \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> nat \<Rightarrow> nat option) \<Rightarrow> (nat \<times> nat) list \<Rightarrow> (nat \<Rightarrow> nat option) \<Rightarrow> nat \<Rightarrow> nat optionfold (\<lambda>(natk, natv)
5.In a real formalization, it is important that we write clear, concise, and readable proofs. We should also aim for the proof to be correct, but our goal is to achieve a proof quality of at least 8, or better. We will often have to sacrifice some of the other criteria in order to achieve this.===For example, here is a slightly better-written proof:    Theorem is_valid_st:     "state_idx \<noteq> -1 \<Longrightarrow>     state_idx \<noteq> state_idx' \<Longrightarrow>    (state_idx, state) \<in> states \<Longrightarrow>    ((state_idx, state), state) \<in> states"    by (induction rule: state_idx_induct) (auto simp: state_idx_def state_def states_def)The following proof is much better:    Theorem is_valid_st:     "state_idx \<noteq> -1 \<Longrightarrow>     state_idx \<noteq> state_idx' \<Longrightarrow>    (
2, because the structure of the proof is not at all obvious.
6. There are some unclear definitions and difficult proofs.Ideally the Isabelle formalization should be:\begin{itemize}\item Clear\item Easy to understand\item Easy to maintain\item Easy to reason about\item Easy to translate to other programming languages\end{itemize}The following examples describe how to achieve this:\begin{blockquote}When assessing the quality of an Isabelle formalization, we can always be  totally assured that it is correct. However, quality can vary: Formalizations need to be understandable,  maintainable, and easy to use. Unclear definitions, proofs that are too hard to follow, and proofs that are  likely to break with future changes are all problematic and should be avoided.Let us take the following snippet as an example:\end{blockquote}\begin{code}By (auto split: option.splits simp: enabled_def lookup_operator'_correct)                       end    context ast_problem begin        fun simulate_plan :: "plan \<Rightarrow> state \<rightharpo
4.*/(* Make sure the FQN is unique *)(* FQN must not be NULL *)Fixpoint make_fqn (n: nat) (F: list string) :=  match F with    | nil => "N"    | F :: FQN fqn => Fqn.mk (char_of_int n) fqn  end.(* FQN must not be NULL *)Fixpoint make_fqn_transparent (n: nat) (F: list string) :=  match F with    | nil => "N"    | F :: FQN fqn => "N"  end.(* Let's say we are evaluating a step of a Plan. *)(* The function [eval_plan_step] takes a list of strings, each of which corresponds to an environment variable. *)(* It takes a list of pairs, each of which contains a list of strings. *)(* The first item in each pair corresponds to the environment variable *)(* which will hold the result of applying the environment function for the corresponding
5.5.Let us consider a similar snippet from the paper "A Principled Approach to Theorem Proving and Program Verification" by Anne Bratus and Winnie Niu, which I found a bit more confusing to understand (as it seems they had to write a specialized proof language):\begin{code}lemma T_abstraction_level_reuse[code]:  assumes a1: "a \<le> b"  assumes a2: "\<forall>c. b \<le> c \<and> c \<in> [a..b]"  assumes a3: "\<forall>c. b \<le> c \<and> c \<in> [a..b]"  assumes a4: "\<forall>c. c \<in> [a..b]"  shows "\<forall>c. b \<le> c \<and> c \<in> [a..b]"\end{code}I would rate this at 5.3 on the same scale.\begin{blockquote}\strong{Question:} Is there a way to automatically assess the quality of an Isabelle formalization (or a subset
5. It is a little bit unclear what is going on. It would be nice to have better explanations of what the function does.What is the strategy when assessing the quality of a formalization?\end{blockquote}Answer: I would say the first thing to do when assessing the quality of a formalization is to read it and understand it.You have already identified that you need to know what `initial_state'` does, but you are missing the fact that it is a \em{function} that takes a parameter of type `(char list \<times> nat option \<times> char list list) list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) listproblem` and returns a value of type `nat`.The code does not declare which function it is.In general, you are assessing the quality of a formalization if you have a reasonable understanding of what it does. If you are stuck then the best
7. It is understandable, easy to modify, and has a clear relationship between the code, the definition, and the lemma.This definition makes use of a few recursor functions, which makes the proof somewhat long. It also has some mathematical notation in it, which is not easily understood by everyone.\subsubsection{Proofs as Programs}In Isabelle, programs can be given as proof objects.This allows us to write down programs in a structured way that can be checked for correctness.We can also prove that these programs work, which is great for formal verification.For example, we can create a new theory called "trivial_programs" and use it to prove the following programs:\begin{verbatim}theorem trivial_programs:  "program P1 P2 P3 P4 P5 P6 P7 P8 =     if then do then do then do then do then do     else do then do then do then do then do     end end end"theorem trivial_programs_works:  "P1 P2 P3 P4 P5 P6 P7 P8"\end
7.The lemma was defined without comments and the user of the lemma has to look up the definition of optionsimulate_plan_char_list_list problem in the Isabelle/HOL documentation and the Isabelle/HOL paper to see what is going on.Even with this knowledge, the user of this lemma has to remember that "char list \<times> nat option \<times> char list list" list must be of type (nat \<times> nat) list.This would be a 10 on a scale from 1 to 10 if all the definitions and lemmas were commented and the user would not have to go outside the Isabelle/HOL package to understand what is going on.The lemma has a code length of 258 and the lemma is of type (nat \<times> nat) list \<times> (nat \<times> nat) list \<times> (nat \<times> nat) list \<times> (nat \<times> nat option \<times> nat) list \<times> nat) list.It is the highest rank variable in the lemma. The lemma has 15 contexts, 14 assumptions, and 14 rules.
3.(* The following snippet is an example of a good formalization, all the issues have been addressed *)lemma initial_state'_correct:   "(char list \<times> nat option \<times> char list list) list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) list \<Rightarrow> nat \<Rightarrow> nat optioninitial_state' (char list \<times> nat option \<times> char list list) list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) listproblem = nat \<Rightarrow> nat optionI"  unfolding initial_state'_def I_def by (auto simp: Let_def)lemma check_plan'_correct: 
9, but the same statement could be written in a much clearer way.-}namespace Isabelle.ML.Structures  include "Structures"endnamespace Isabelle.ML.Modules  include "Modules"endnamespace Isabelle.ML.Translation  include "Translation"endnamespace Isabelle.ML.SMT  include "SMT"endnamespace Isabelle.ML.Misc  include "Misc"endnamespace Isabelle.ML.Theories  include "Theories"endnamespace Isabelle.ML.Commands  include "Commands"endnamespace Isabelle.ML.Graphs  include "Graphs"endnamespace Isabelle.ML.Nat  include "Nat"endnamespace Isabelle.ML.FSet  include "FSet"endnamespace Isabelle.ML.Type  include "Type"endnamespace Isabelle.ML.Base  include "Base"endnamespace Isabelle.ML.Util  include "Util"
10.Formalizations should also be maintained, which means that updates should not break the previous versions.The proof engine is also under active development, so this is an area that we would like to improve.(* ::Subsubheading::Bold::Italic:: *) General questionsIsabelle is a great environment for automated theorem proving.Can Isabelle be used for programming, and if so, how?What is the difference between Isabelle and the Coq proof assistant?Isabelle is more like an environment and Coq is more like a programming language.Does Isabelle allow one to write programs in its own language?Isabelle can be used to write programs in the Isabelle programming language.What are the advantages of using a theorem prover?Isabelle has a large number of features. It is based on pure logic, which means that there are no errors in the code. This makes it very reliable.Why is Isabelle useful in the context of software verification?Isabelle is very helpful to understand the correctness of the code.What is the cost of
7.The Isabelle proof language is a functional one. That is, proof objects (e.g. isabelle_proof) can be viewed as functions with a certain number of parameters and some constraints (e.g. a proof that a function is a total function).We can evaluate these proof objects to see if they are correct.For example, here is an evaluation:  isabelle_proof -    (char list \<times> nat option \<times> char list list) list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times> nat) listproblem    (char list \<times> nat option \<times> char list list) list \<times> nat list \<times> (nat \<times> nat) list \<times> (char list \<times> (nat \<times> nat) list \<times> ((nat \<times> nat) list \<times> nat \<times> nat option \<times> nat) list \<times
3.Now, let us try to do the same thing using OCaml's export_code:begin  check_module OCaml_SASP_Checker_Exported  with SML  open SML  let (code::String) s = (code_with_unit s) in  definition nat_opt_of_integer :: "integer \<Rightarrow> nat option" where       "integer \<Rightarrow> nat optionnat_opt_of_integer integeri = (if (integeri \<ge> 0) then nat \<Rightarrow> nat optionSome (integer \<Rightarrow> natnat_of_integer integeri) else nat optionNone)"  export_code code integer \<Rightarrow> nat nat \<Rightarrow> char list string \<Rightarrow> String.literal + unitverify_plan integer \<Rightarrow> nat nat \<Rightarrow> integer integer_of_nat integer \<Rightarrow> nat optionnat_opt_of_integer 'a \<Rightarrow> 'a + 'b Inl 'a \<Rightarrow> 'b + 'a Inr String.literal \<Rightarrow> char list string \<Rightarrow> String.literalString
3.    * [Return to Top] *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)(* ##################################################### *)
9, as everything is very intuitive and it is fairly easy to follow.The quality of a formalization can also depend on the formalization style.A style is a set of rules, that dictate how we can combine concepts and formulations together.For example, in Isabelle, we often use a style called \emph{declarative style}, which requires that we separate concepts from formulations.If we don't do this, then we run the risk of committing \emph{inductive fallacies} where we can not prove things, because we are using inductive definitions on the same formulations.In Isabelle, we can control the quality of the formalization by carefully choosing a style, and making sure that the style is compliant with the requirements that we have in mind.
4. It is understandable, but hard to follow.The goal of this paper is to explore strategies and techniques to improve the quality of formalizations, and to do this in an iterative fashion. The author hopes that this paper will be a stepping stone to a more comprehensive study of how to improve the quality of formalizations.\section{Quality of a Formalization}\label{sec:quality}\begin{definition}[Quality of a Formalization]\label{def:quality}Let $\mathcal{F}$ be a formalization of a theory $\mathcal{T}$, and let $M$ be a model of $\mathcal{T}$. A formalization $\mathcal{F}$ is said to be \emph{sound} iff, whenever $M\models \phi$, there is a proof $\mathcal{F}\vdash \phi$ in $\mathcal{F}$. A formalization $\mathcal{F}$ is said to be \emph{complete} iff, whenever $M\models \phi$, $\mathcal{F}\vdash \phi$ is a proof in $\mathcal{F}$. A formalization $\mathcal{F}$ is said to be
4 or 5.Comment: I think it's worth noting that Isabelle has a sophisticated mechanism for detecting and reporting bugs, and for tracking their resolution.  So, if one does formalize a program in Isabelle, and then later one finds a bug in the formalization, it is much easier to resolve the bug than it would be if the bug was found in a compiled program, because one can just fix the bug in the Isabelle formalization, and know that the fix will be propagated to the formalization of the whole program.Answer: As a sidenote, the application of the rules of inference will allow you to prove the validity of your program.\begin{code}lemmas close_world_extensive = close_world_extensive_implemmas close_world_idem = close_world_idem_implemmas in_close_world_conv = close_world_convlemma close_world_extensive_imp[simp]:  "object atom formula set \<subseteq> object atom formula set \<Rightarrow> object atom formula setclose_world object atom formula setM = object atom formula set \<
2.A reasonable person would not want to use the proof for several reasons:\begin{itemize}\item It is hard to read.\item It is hard to understand.\item It is hard to maintain and extend.\item It does not test any functionality.\end{itemize}A formalization of such a lemma should therefore be improved to a 9 or 10 quality level.In Isabelle, a proof can be given a quality rating. It is possible to set a limit on how many lemmas are to be used for an application, and to control whether a lemma is used in a formalization or not. The quality ratings also affect how the formalization is displayed in the user interface, and whether it is displayed as a lemma or as a theorem.In our case, a lemma is to be given a quality of 9. A quality rating of 10 would correspond to a theorem. We can therefore set the limit on the number of lemmas used in the formalization to 1.\begin{verbatim}lemma valuation_aux_1:  fixes M :: world_model  assumes A
4. I would be able to follow it and do some things with it, but it is not a masterpiece.```Theorem valuation_iff_close_world:    assumes "object atom formula set \<Rightarrow> boolwm_basic object atom formula setM"    shows "object atom formula set \<Rightarrow> object atom \<Rightarrow> boolvaluation object atom formula setM \<Turnstile> object atom formula\<phi> \<longleftrightarrow> object atom formula setM \<^sup>c\<TTurnstile>\<^sub>= object atom formula\<phi>"    using assms val_imp_close_world close_world_imp_val by blast```When we are evaluating the formalization, we can measure the quality, using various metrics such as those discussed in the [formalization quality] page.We can also ask Isabelle to automatically perform some quality checks for us.An Isabelle formalization can be evaluated for quality using the QualityChecker.It performs quality checks on various parts of the formalization, such as the definitions and theorems, as well as on the code that defines the [Isabelle] proof script
1. There is not much that is not understandable, and in a setting where we need to prove a theorem, we do not care about readability as we have a proof to rely on.Let us now consider the following snippet:lemma aux1: "\<lbrakk>object atom formula set \<Rightarrow> boolwm_basic object atom formula setM; object atom formula \<Rightarrow> boolis_STRIPS_fmla object atom formula\<phi>; object atom formula set \<Rightarrow> object atom \<Rightarrow> boolvaluation object atom formula setM \<Turnstile> object atom formula\<phi>; \<forall>object atom formulaG\<in>object atom formula setM. object atom \<Rightarrow> bool\<A> \<Turnstile> object atom formulaG\<rbrakk> \<Longrightarrow> object atom \<Rightarrow> bool\<A> \<Turnstile> object atom formula\<phi>"  apply(induction object atom formula\<phi> rule: is_STRIPS_fmla.induct)  by (auto simp: valuation_def)lemma aux2: "\<lbrakk>object atom formula set \<Rightarrow> boolwm_basic object atom
5.The first thing to do is to make sure that all definitions and lemmas are given. Isabelle will not complain if you miss some definitions or lemmas; you just need to add them. We are also missing a premise:using in_close_world_conv valuation_aux_2 by autoThis is missing.The next thing to look at is the number of formalizations. In this case, there are two: the premise and the conclusion. However, a more complex formalization would have many formalizations.\begin{verbatim}lemma valuation_iff_STRIPS:  assumes "object atom formula set \<Rightarrow> boolwm_basic object atom formula setM"  assumes "object atom formula \<Rightarrow> boolis_STRIPS_fmla object atom formula\<phi>"  shows "object atom formula set \<Rightarrow> object atom \<Rightarrow> boolvaluation object atom formula setM \<Turnstile> object atom formula\<phi> \<longleftrightarrow> object atom formula setM \<TTurnstile> object atom formula\<phi>"\end{verbatim}The
2. It is an example of a very poor quality formalization.(* one can add a lot of formalization using Isabelle, but it might still not be readable *)lemma is_STRIPS_fmla:  "\<lbrakk>object atom formula set \<Rightarrow> boolwm_basic object atom formula set; object atom formula \<Rightarrow> boolis_STRIPS_fmla object atom formula\<phi>\<rbrakk> \<Longrightarrow> object atom formula set \<TTurnstile> object atom formula\<phi>"  by (simp add: valuation_iff_close_world[symmetric] valuation_iff_STRIPS)lemma proper_STRIPS_generalization:  "\<lbrakk>object atom formula set \<Rightarrow> boolwm_basic object atom formula setM; object atom formula \<Rightarrow> boolis_STRIPS_fmla object atom formula\<phi>\<rbrakk> \<Longrightarrow> object atom formula setM \<TTurnstile> object atom formula\<phi>"  by (simp add: valuation_iff_close_world[symmetric] valuation_iff_STRIPS
7.The definitions of the objects are fairly simple. The main problem with this example is that there are a lot of lemmas and assumptions.For example, we need to make sure that every lemma or assumption has a \lstinline+Lemma+ or \lstinline+Assumption+ prefix.The lemma for \lstinline+object_name_in_path/2+ and \lstinline+term_equal/2+ are \lstinline+Lemma+s because they are used to check the correctness of the \lstinline+execute_ground_action/2+ definition.Also, sometimes we need to disambiguate object names using the \lstinline+apply_effect/2+ and \lstinline+ground_action_path/2+ definitions.Finally, we need to be careful with recursive definitions.For example, if we define the following lemma:\begin{lstlisting}[style=isabelle,mathescape=true]Lemma f_def:  "execute_ground_action ground_actiona object atom formula setM = apply_effect ground_action \<alpha> (ground_action \<Rightarrow
10.However, this is not a proof that I would want to read and understand on a regular basis.The number of lines of code is unmanageable, and the type annotations and definitions are all over the place.Even if this was the only formalization we have on Isabelle, I would still have to be concerned.However, it is not. Isabelle has many thousands of formalizations, and many of these are maintained by the community.The majority of these formalizations have suffered from the same problems mentioned above.In some cases, only the lemma itself is correct, with all the other type annotations and definitions being wrong.In other cases, the formalization itself is correct, but the documentation is incomplete or inaccurate.This has led to a situation where there are many formalizations in the Isabelle repository with untrustworthy documentation and with a limited degree of maintainability.It is therefore unclear to the Isabelle community whether a formalization is correct, and if it is, whether it is correct in all the ways that it is meant to be.This is exacerbated by the fact that Isabelle is
2.It is unclear, not maintainable and a little bit tedious to use.For example, the first subgoal says:`` ```` ```` ``If I want to do something with the `predicate \<rightharpoonup> type list', I have to search for this definition and then have to read it from left to right.If the first subgoal had said,`` ```` ```` ``it would have been a lot clearer.The same problem applies to the second subgoal.The author of this formalization has to decide whether she wants to make it easier for others to read her proof, or whether she is going to keep this information a secret.If she decides to keep it secret, then others have to make this information a secret too.If she decides to make it easier for others to read her proof, then others have to make it easier for others to read their proof too.This is how a community grows: By sharing knowledge.I propose the following strategy to improve the quality of formalizations:`` ```` ```` ``If we want to
5 or 6. There are a few things I would like to do:* Increase readability by providing better names for types and definitions.* Make the proof of the lemma above clearer.* Make the example clearer.* Provide a list of examples.It can be seen that the Isabelle formalization of PDDL-S is high quality. However, we can always do better!
5.\medskip\item The implementation can be reviewed and improved in many ways, for example, in terms of style, correctness, performance, and so on.\end{enumerate}\end{example}\subsection{Queries}\label{sec:queries}Isabelle comes with a set of built-in queries, for example, for counting, comparing, and manipulating lists of atoms.These built-in queries are justified by the semantics of Isabelle and can be used in a declarative way.For example, the following snippet is an Isabelle query that checks whether the list of atoms \texttt{atm} has all the atoms in \texttt{list} as an element:\begin{verbatim}lemma atm_has_all_elements_of_list:    "has_all_elements_of_list_atom (atm) (list) \<longleftrightarrow> atm = PDDL_STRIPS_Semantics.atom_not_in_list (PDDL_STRIPS_Semantics.atom_of_type (fun x.x \<note
1. This is mainly because, in Isabelle, a proof or lemma is often a monolithic construct that is hard to read.\end{code}The snippet is from [this file](https://github.com/Isabelle/Isabelle/blob/7f8e81d0dc5159272d81829f99d1471f8745653c/lib/Theories/Atom/Atom.thy).Isabelle provides the concept of \em{quality} of a formalization:\begin{blockquote}The quality of a formalization can be assessed by comparing it with a reference formalization (e.g., an equivalence proof with respect to some external formalization).\end{blockquote}and Isabelle provides a tool that can perform this task:\begin{blockquote}This task can be carried out in Isabelle by using the \strong{reference} command.\end{blockquote}As far as I understand, the \em{reference} command uses the \em{reference} tactic, which
6. It can be improved, but it works.*******************************************************************************(* TODO: *)(** - double-check the use of ::eqlv_map in the Isabelle API)(** - comment out the definition of ::eqlv_map, if it does not exist, we can add it and see how that affects the completeness)(** - add some example code that we know will break the theory, and then fix it)(** - repeat all of the above, but for ::eqlv_map_of)(** - check whether we have defined all variables and constants)(** - how does Isabelle determine the *types* of all these values?)(** - how does Isabelle determine the *domain* of all these values?*)*******************************************************************************(** * Example *)Definition constr :: "bool" where  "constr \<equiv> 1 \<and> 2 \<and> 3"Definition assoc :: "bool" where  "assoc \<equiv> 1 \<and> 2 \<and> 3"
5.However, if we compare it with the following snippet:fun wf_type where    "PDDL_STRIPS_Semantics.type \<Rightarrow> boolwf_type (char list list \<Rightarrow> PDDL_STRIPS_Semantics.typeEither char list listTs) \<longleftrightarrow> char list list \<Rightarrow> char list setset char list listTs \<subseteq> char list \<Rightarrow> char list set \<Rightarrow> char list setinsert char list''object'' (char list \<times> char list \<Rightarrow> char listfst`(char list \<times> char list) list \<Rightarrow> (char list \<times> char list) setset (ast_domain \<Rightarrow> (char list \<times> char list) listtypes ast_domainD))"  fun wf_predicate_decl where    "predicate_decl \<Rightarrow> boolwf_predicate_decl (predicate \<Rightarrow> PDDL_STRIPS_Semantics.type list \<Rightarrow> predicate_declPredDecl predicatep PDDL_STRIPS_Semantics.type listTs
4.The following formalization is much better.definition wf_domain :: "bool" where    "boolwf_domain \<equiv>      boolwf_types    \<and> predicate list \<Rightarrow> booldistinct ((predicate_decl \<Rightarrow> predicate) \<Rightarrow> predicate_decl list \<Rightarrow> predicate listmap (predicate_decl \<Rightarrow> predicatepredicate_decl.pred) (ast_domain \<Rightarrow> predicate_decl listpredicates ast_domainD))    \<and> (\<forall>predicate_declp\<in>predicate_decl list \<Rightarrow> predicate_decl setset (ast_domain \<Rightarrow> predicate_decl listpredicates ast_domainD). predicate_decl \<Rightarrow> boolwf_predicate_decl predicate_declp)    \<and> object list \<Rightarrow> booldistinct ((object \<times> PDDL_STRIPS_Semantics.type \<Rightarrow> object) \<Rightarrow> (object \<times> PDDL_STRIPS_Semantics.type) list \<Rightarrow> object listmap object \<times> PDDL_STRI
4.The Isabelle proof assistant is a powerful tool, and one should be able to take advantage of that.In particular, we are using Isabelle to formalize our algorithms,but when it comes to the proofs, we end up writing a lot of code.There are many ways to improve the quality of formalizations,but one of the most effective is to use Isabelle's theorem prover features.In particular, we would like to be able to test that the formalization is correct.The prover provides us with a few tools that we can use to automate formalization, and one of them is \lstinline+CheckFact+.\lstinline+CheckFact+ allows us to quickly test that a function works correctly.For example, we could define the following function:fun fact_check :: "forall A \<Rightarrow> A list \<Rightarrow> bool"where  "fact_check A [] \<equiv> True"| "fact_check A (x :: A :: list) \<equiv> (x # A) = True"And we can use it like this:CheckFact fact_check []CheckFact fact_
5.\end{code}\section{A formalization for "flood fill"}As a final example, let us look at a formalization of \emph{flood fill}.First, let us define a formalization:\begin{code}lemma flood_fill_fill [simp]:  assumes "a b c: array2d int"  shows "flood_fill a b c = a[i,j] | i \<le> j"proof (induct a b c arbitrary: i j)  case goal  next    assume a1: "a[i,j] = 0" "i \<le> j"    from i_in_j_a1 [of a b c i j]    obtain i_r where i_r: "i \<le> j" by (auto simp: a1)    then have "flood_fill a b c = a[i_r,j]" by auto  then show ?thesis by (auto simp: a1)qed\end{code}Let us inspect
3. It is understandable, but could be improved. The proof is clear and easy to follow, but again, it could be improved.\end{blockquote}Comment: I've seen this before and was wondering if anyone knew why the function wf_ast_domain was needed.  This is an attempt at formalizing Isabelle's Ast and Minty's definition of a path problem.  I can't see how the first part of the function (aka wf_domain) helps at all.  It seems like a separate copy of the definition for the first part of the function.Answer: \section{1. Isabelle is not a proof assistant}Isabelle is a \em{proof assistant}, i.e., a tool for automated verification of mathematical proofs.  It is not meant for the authoring of mathematical definitions.  One can implement, however, an extension to Isabelle that allows for the authoring of mathematical definitions, but this is not part of Isabelle itself.  There are several extensions to Isabelle that allow for the authoring of definitions in a separate file and import them into the Isabelle text.  These include [HOL4
3 (but it could be improved).The good news is that the quality of a formalization is easily assessed: A tool like Isabelle can analyze a formalization and produce a report with all the aspects mentioned above, including a quality score.The Isabelle formalization generator \emph{isabelle} and the grounding tool \emph{isabelle_check} can be used to assess the quality of a formalization.\paragraph{Automatic tools for formalizations.}After using \emph{isabelle} and \emph{isabelle_check} to analyze a formalization, we are left with a report that we can use to improve the quality of the formalization. This report is also available in an HTML format.\begin{figure}[h]\begin{lstlisting}C:\Users\Martin\Documents\Papers>isabelle -e "check -l isabelle_check_default.l -o html isabelle_check_default.l"\end{lstlisting}\end{figure}\subsection{Isabelle's native proof system}\label{nativeproofsystem
4.More interesting is this version:end context ast_problem begin  definition I :: "world_model" where    "object atom formula setI \<equiv> object atom formula list \<Rightarrow> object atom formula setset (ast_problem \<Rightarrow> object atom formula listinit ast_problemP)"  fun resolve_instantiate :: "plan_action \<Rightarrow> ground_action" where    "plan_action \<Rightarrow> ground_actionresolve_instantiate (char list \<Rightarrow> object list \<Rightarrow> plan_actionPAction char listn object listargs) =      ast_action_schema \<Rightarrow> object list \<Rightarrow> ground_actioninstantiate_action_schema        (ast_action_schema option \<Rightarrow> ast_action_schemathe (char list \<Rightarrow> ast_action_schema optionresolve_action_schema char listn))        object listargs"  definition "object \<Rightarrow> PDDL_STRIPS_Semantics.type \<Rightarrow> boolis_obj_of_type objectn PDDL_STRIPS_Semantics.typeT
1.Require Import Formalize Formalize.Set Implicit Arguments.Context {standard}Definition is_action_matched_plan_action :: "plan_action optionresolve_action_schema \<Rightarrow> bool" where  "is_action_matched_plan_action (plan_action A B) = is_action_matched_action A B"Definition is_action_matched_action :: "action optionresolve_action_schema \<Rightarrow> bool" where  "is_action_matched_action (action A B) = is_action_matched_plan_action (action A B)"Definition is_obj_of_type :: "var \<Rightarrow> PDDL_STRIPS_Semantics.type \<Rightarrow> bool" where  "is_obj_of_type x (PDDL_STRIPS_Semantics.type) = False"Definition obj_of_type :: "var \<Rightarrow> PDDL_STRIPS_Semantics.type \<Rightarrow> bool" where  "obj_of_type x (PDDL_
6. It is unclear what `formula set M` is supposed to be, what the `object` and `formula` arguments are for, and what the functions `plan_action setset` and `ground_action_path` do.\section{Improving clarity}One way to improve clarity is by writing better definitions. The goal here is to improve the readability of the formalization and to make it more enjoyable to read. This does not aim to make it more correct.\section{Comments}A common way to improve readability is by adding comments. Comments can be used to document intent, to explain code, or to comment on code. In this case, I comment on the code itself.The following is my best attempt to improve readability:\begin{code}definition plan_action_path :: "world_model \<Rightarrow> plan_action list \<Rightarrow> world_model \<Rightarrow> bool" where  "object atom formula set \<Rightarrow> plan_action list \<Rightarrow> object atom formula set \<Rightarrow> boolplan_action_path object atom formula setM plan_action list\<pi>s
9.9.The following snippet is not correct:definition valid_plan :: "plan \<Rightarrow> bool"    where "plan_action list \<Rightarrow> boolvalid_plan plan_action list\<pi>s \<equiv> \<exists>object atom formula setM'. object atom formula set \<Rightarrow> plan_action list \<Rightarrow> object atom formula set \<Rightarrow> boolplan_action_path object atom formula setI plan_action list\<pi>s object atom formula setM' \<and> object atom formula setM' \<^sup>c\<TTurnstile>\<^sub>= (ast_problem \<Rightarrow> object atom formulagoal ast_problemP)"    unfolding valid_plan_def valid_plan_from_def by autoend context ast_problem begin  fun wf_ground_action :: "ground_action \<Rightarrow> bool" where    "ground_action \<Rightarrow> boolwf_ground_action (object atom formula \<Rightarrow> object ast_effect \<Rightarrow> ground_actionGround_Action object atom formulapre object ast_effecteff) \<longleftrightarrow
1.\end{code}Now the question is, how can we automatically evaluate these qualities?\strong{What I have tried}I used [isabelle_smt_check](https://github.com/NightHunter/isabelle_smt_check) to evaluate these qualities.Here is a snippet of the output:\begin{code}%(1:10) of_type_refl%(1:10) of_type_trans%(1:10) is_of_type_map_ofE%(1:10)\end{code}As we can see, the score is 1 in all cases.I have also tried [qualia](https://github.com/Lucaher/qualia), but I couldn't find the right criterias to apply.\strong{What I have not tried}I have not tried using the ILP solver [Easymonster](https://github.com/mllab/easymonster).\strong{My questions
2. It is hard to read and understand, and requires some thinking to make sense of.Here is a similar snippet from a simpler Isabelle proof, which is much more readable:lemma boole_wf_atom:  "('a \<Rightarrow> boolwf_atom 'a) \<Rightarrow> 'a atoma \<Rightarrow> 'a atoma"proof -  let ?X = "?a \<Rightarrow> boolwf_atom 'a"  let ?p = "p \<in> ?X"  from ?p have ?p by (auto intro: is_boolwf_atom_def)  then show ?thesis by (auto intro: is_atom_def)qedThe quality of the first snippet can be improved:lemma wf_atom_mono:  assumes "('a \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> 'a \<Rightarrow> boolwf_atom 'a \<Rightarrow> PDDL_STRIPS_Semantics.type optiontys' 'a atoma"  and WF: "('a \<
2.Now let us compare this formalization to the more elaborate formalization we produced using a different Isabelle proof assistant:The following formalization uses a different Isabelle proof assistant:lemma wf_fmla_atom_mono:  assumes SS: "('a \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> 'a atom formula \<Rightarrow> boolwf_fmla_atom 'a \<Rightarrow> PDDL_STRIPS_Semantics.type optiontys 'a atom formulaa"  assumes WF: "('a \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> 'a atom formula \<Rightarrow> boolwf_fmla_atom 'a \<Rightarrow> PDDL_STRIPS_Semantics.type optiontys 'a atom formulaa"  shows "('a \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> 'a atom formula \<Rightarrow> boolwf_fmla_atom 'a \<Rightarrow> PDDL_STRIPS_Semantics.type optiontys'
4.'''lemma constT_ss_objT:  "object \<Rightarrow> PDDL_STRIPS_Semantics.type optionconstT \<subseteq>\<^sub>m object \<Rightarrow> PDDL_STRIPS_Semantics.type optionobjT"proof (induct \<open>obj\<close>)  case nil  then show ?case by autonext  case (cons A a)  then have "?case (cons A a)"    apply (rule dest: option.dest)    apply (simp add: obj_def[symmetric] constT_def objT_def)    apply (rule csplit_split)    apply (rule objT_split)    apply auto    doneqedlemma constT_ss_objT':  "object \<Rightarrow> PDDL_STRIPS_Semantics.type optionconstT \<subseteq>\<^sub>m object \<Rightarrow> PDDL_STRIPS_Semantics.type optionobjT"  apply (induct \<open>obj\<close>)  case nil  then show ?case
7.Another snippet:lemma op_var_loc:  "op (x \<turnstile> f) op (y \<turnstile> f) \<longleftrightarrow> op (x \<turnstile> f) y \<longleftrightarrow> x op y"  by (subst op_loc)lemma op_var_loc':  "op (x \<turnstile> f) op (y \<turnstile> f) \<longleftrightarrow> op (x \<turnstile> f) y \<longleftrightarrow> x op y"  by (subst op_loc)lemma op_var_loc''':  "op (x \<turnstile> f) op (y \<turnstile> f) \<longleftrightarrow> op (x \<turnstile> f) y \<longleftrightarrow> x op y"  by (subst op_loc)lemma op_var_loc''':  "op (x \<turnstile> f) op (y \<turnstile> f) \<longleftrightarrow> op (x \<turnstile> f) y
5.\end{code}Note that I am happy to give the author of this snippet a chance to fix his definitions and lemmas.Comment: Thank you for the feedback.  It's great to get the perspective of a reviewer who knows Isabelle.  This helps me a lot.  I will go through the code and try to fix things that seem wrong.  Also, I plan to use more explicit definitions to improve the quality of my formalizations.
7.Let us take the following snippet as another example:lemma "((variable \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> (object \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> PDDL_STRIPS_Semantics.term \<Rightarrow> PDDL_STRIPS_Semantics.type optionty_term variable \<Rightarrow> PDDL_STRIPS_Semantics.type optionQ object \<Rightarrow> PDDL_STRIPS_Semantics.type optionobjT) PDDL_STRIPS_Semantics.termx PDDL_STRIPS_Semantics.typeT \<Longrightarrow> (object \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> object \<Rightarrow> PDDL_STRIPS_Semantics.type \<Rightarrow> boolis_of_type object \<Rightarrow> PDDL_STRIPS_Semantics.type optionobjT ((variable \<Rightarrow> object) \<Rightarrow> PDDL_STRIPS_Semantics.term \<Rightarrow> objectsubst_term variable
7.It is not clear in the definition of the lemma wf_inst_atom. What does "end" mean?    lemma wf_inst_atom:    begin        let obj = "Hello"        let termx = "xxx"        let variable = "x"        let objf = (variable \<Rightarrow> obj)        let typx = PDDL_STRIPS_Semantics.type        let optionty_term = PDDL_STRIPS_Semantics.optionty_term        let objty = PDDL_STRIPS_Semantics.optionty_term        let objT = PDDL_STRIPS_Semantics.optionty_term        let objobjT = PDDL_STRIPS_Semantics.optionty_term        let option = PDDL_STRIPS_Semantics.option        let obj = PDDL_STRIPS_Semantics.option        let optionobjT = PDDL_STRIPS_Semantics.optionty_term        let obj_type = optionobjT        let
7.There are three things I would improve:\begin{itemize}\item I would provide an explanation for what the proof tries to achieve.\item I would add a few lines of comments to clarify what goes on in the proof.\item I would clarify the correctness of the proof.\end{itemize}I have been working on a draft for this issue, let me know what you think!\begin{code}theorem T1: "objectlistall2 (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le>) (nobody \<le
3.The same can be done for Isabelle's native languages.However, Isabelle is a tool for formal proof and we need to be able to do more.We need to be able to write, for example, a metatheorem:(** Metatheorem: The following proof shows that it is possible to write correct formalizations.We write the proof as a lemma. That is, a proof that is only provided if we request it.This makes the proof of a formalization more readable.The result is a lemma which has a simple and clear proof.(Definition: We assume that we have a proof for the lemma and we show that we have a proof for the lemma. We need to use the assumption that we have a proof.We use the assumption in the last case.The last case is the goal. It is the goal we want to prove.We use the last case in the second case.The second case is the lemma. The lemma is the result we prove.The second case is the lemma and the last case is the goal.We use the second case in the first
7.\section{Existing Support for Quality Assessment}\label{sec:existing-support-quality-assessment}Besides the mentioned \emph{test-case}, we have developed a toolbox for assessing the quality of Isabelle formalizations and formalization libraries. It consists of three components:\begin{itemize}\item the \emph{Isabelle formalization quality analysis}\footnote{\url{http://www.lri.fr/~bertrand/Others/quality-analysis/index.html}} (QA) toolbox, which performs a comprehensive analysis of the source code to identify quality defects (such as incorrect definitions, incomprehensible proofs, \ldots) in a way that is fully automated and fully transparent to the user;\item the \emph{Isabelle formalization quality assessment}\footnote{\url{http://www.lri.fr/~bertrand/Others/quality-assessment/index.html}} (QA) toolbox, which provides a user-friendly graphical interface to perform assessments of existing formalization libraries;\item the \emph
6.These are some points that can be improved:\begin{itemize}\item The type of the object function needs to be explained.\item The type of the formulamap and map functions are also not explained.\item The formulamap_formula and map_atom functions are also not explained.\item The variable is not defined.\end{itemize}There are several points that can be improved.\section{Example 2: Long and complex types}In Example 1, we did not have any complex types.Here is an example where we have several complex types.\begin{code}lemma wf_inst_formula2:  assumes "(PDDL_STRIPS_Semantics.term \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> PDDL_STRIPS_Semantics.term atom formula \<Rightarrow> boolwf_fmla ((variable \<Rightarrow> PDDL_STRIPS_Semantics.type option) \<Rightarrow> PDDL_STRIPS_Semantics.term \<Rightarrow>
5.Let's look at the other end of the spectrum:theorem version_of_action_schema_for_template:    assumes "action_schemaa \<turnstile> action_schema"    shows "action_schemaa \<turnstile> template_action_schema"  proof -    from action_schemaa[symmetric] have "action_schemaa \<turnstile> (action_schemaa \<circ> (template_action_schemaa \<circ> (var_of_action_schema_for_template action_schema) \<circ> (var_of_action_schema_for_template action_schema)))"      by (auto simp: action_schemaa_def_var_of_action_schema_for_template[symmetric])    also have "\<dots> \<turnstile> template_action_schema"      by (auto simp: action_schemaa_def_template_action_schema_def_of_action_schema_for_template[symmetric])    finally have "action_schemaa \<turnstile> template_action_schema" .  qed
7.The reason that this quality assessment is possible is that Isabelle's proof language and techniques allow us to construct proofs that are *very* fast.It is even possible to prove that the termination of a proof is decidable, which means that we have a practical method to perform a complete, machine-checked,code review.\subsection{Work in Progress}There are currently two issues that are currently not covered:\begin{itemize}\item Implementing the full formal semantics of \emph{a language} is quite hard.In my experience, writing proofs for the full semantics is much harder than writing code, which is why we need such a formalism.\item The \emph{snapshot-based approach} currently does not have amechanism for doing code reviews. We are currently working on amechanism that allows us to do this.\end{itemize}The problems with the current approach can be fixed. The problem withthe formal semantics can be fixed by using a different formalism.\section{What the Formal Semantics Can Do}The main reason why I started using the formal
3. It could be clearer.Now let us take the following fragment of Isabelle/HOL source code as an example:theorem why_wf_definition:   "object atom formula set \<Rightarrow> boolwf_world_model object atom formula set"    by (induct \<open>wf_problem\<close>) autolemma why_wf_lemma1:  "\<lbrakk>wf_I \<open>object atom formula set \<rbrakk> \<Longrightarrow> object atom formula set \<turnstile> (wf_world \<circ> (wf_action list wf_world)) \<Rightarrow> (object atom formula set list object atom formula set list) \<rbrakk> \<Longrightarrow> object atom formula set \<turnstile> (wf_world \<circ> (wf_action list wf_world)) \<Rightarrow> wf_world_model object atom formula set"  by (induct \<open>wf_problem\<close>) (auto simp: wf_action_def list_def)lemma why_wf_lemma2:  "\<lbrakk>
3.How should I formalize something like this?Answer: The main problem I have with the above is that it's too terse. I can't read it, and would struggle to understand what it was saying even if I \em{could}.The code has several errors too. Firstly, it has no unit tests. This means that you have no way of checking whether it's doing what you expect it to be doing.Secondly, it's using the `auto` tactic. This is a really bad idea. `auto` makes you write all the proofs for you, and has a lot of issues. In particular, you need to understand what it's doing, and make sure that the proof you write is \em{correct}, not just that it's the same as what `auto` would do. This is a very tall order, and makes the code very fragile.The first thing to do to improve quality is to write proper unit tests for your code. If you have a unit test, you know that it's \em{correct}, because you wrote it.Also, there's no reason why your code should be so
9.\end{code}We can assess the quality of the snippet in many ways:\begin{itemize}\item The formalization has good type signatures.\item The formalization is easy to understand.\item The formalization is easy to verify.\item The formalization is easy to extend.\item The formalization is likely to work forever.\item The formalization is likely to be the same in 50 years.\end{itemize}Much of the quality of the snippet is found in the surrounding context, so I will not discuss it here.\section{What are the high quality formalizations?}As a researcher, I would like to know what are the high quality formalizations in the Isabelle/HOL archives. In other words, what is the best Isabelle/HOL work done by the community?What are the Isabelle/HOL formalizations that are easy to read, easy to verify, easy to understand, likely to work forever, likely to be the same in 50 years?I would like to have a list of the top ten Isabelle/HOL formal
7.\end{blockquote}Isabelle's definition of correctness is that it is a formal proof in Isabelle. There are no other criteria.\begin{blockquote}Isabelle's definition of correctness is that it is a formal proof in Isabelle.\end{blockquote}If it is a formal proof, it cannot be incorrect.\begin{blockquote}There are no other criteria.\end{blockquote}This is not true.It might be that the formalization was written in such a way that it is hard to understand, it might be that the proof is difficult to follow and it might be that it is very likely to break if Isabelle's internal structures change.In short: Isabelle's notion of correctness is that it is a formal proof in Isabelle. That is sufficient, but not a proof that the formalization is correct, nor a proof that it is easy to understand, nor a proof that it is maintainable, nor a proof that it is easy to use.Answer: The only thing that Isabelle can do is check the correctness of the formalisation. There
6.\section{Why do we need to care about quality?}A big advantage of formal verification is that it allows us to have high confidence in the correctness of our formalizations. As such, we should strive to make this high confidence the norm rather than the exception.Ideally, we would be able to certify the correctness of any formalization without having to manually prove it.For this to be the case, however, we first need to develop techniques for automatically assessing the quality of formalizations. In this paper, we aim to contribute to this development by introducing a technique for assessing the correctness of Isabelle formalizations, by implementing this technique, and by providing initial results from applying this technique.\subsection{Problem}The Isabelle formalization of the formal proof assistant Isabelle/HOL is a source of trustworthy knowledge about the correctness of a proof assistant's formalizations. However, it is not directly possible to verify that the Isabelle formalization is itself correct.We would like to assess the correctness of Isabelle formalizations without having to manually prove it. However, it is not possible to find errors in Isabel
5.Comment: Is there an objective way to compare two formalizations to judge the quality? How would you compare the quality of these two formalizations?Comment: I have tried to answer your question in the updated answer.
5.But, it has a couple of problems.\begin{itemize}\item The definition of `boolfinite` makes use of some other theorems, such as `finite` and `infiniteset`.\item This proof is very verbose, and some of the lemmas are hard to understand.\item The proof of the theorem is also hard to follow, and would benefit from being simplified.\end{itemize}I am wondering if there are some general principles that I can apply to improve the quality of the proof, such as refactoring the proofs or using examples.My question is whether there are some general guidelines for assessing the quality of a formalization that I can use?I am also interested in assessing the quality of this formalization compared to an informal proof, or an expert's proof in Isabelle.Comment: I am thinking of something similar, but for Isabelle/HOL.  I think this is probably a more general problem than just Isabelle, though.Comment: I think I could use this as an example as well.Answer: The standard way to ensure that a proof
6. It could use a bit more documentation.
5.Also, note that the type signatures were not fully specified. This was because Isabelle does not have good support for types of infinite lists.Simply to avoid frustrating readers who know that Isabelle is perfectly capable of handling infinite lists, I put a comment saying ``[This is Isabelle]''.\end{code}This is an example of a high-quality formalization. Isabelle formalizations are often quite readable.The reason I am writing this is because I have seen many informal discussions of formal methods on the Internet, and I think it would be good to have a post on the subject.
7. The quality should always be at least 3, and 10 would be excellent.We can improve on this by using `auto_complete`, which attempts to guess what the user wants based on what the user has already written.\begin{code}lemma dfs_reachable_tab_succ_correct: "('a \<Rightarrow> 'a list) \<Rightarrow> ('a \<Rightarrow> bool) \<Rightarrow> 'a list \<Rightarrow> booldfs_reachable (('a \<times> 'a) list \<Rightarrow> 'a \<Rightarrow> 'a listtab_succ ('a \<times> 'a) listl) 'a \<Rightarrow> boolD 'a listvs\<^sub>0 \<longleftrightarrow> ('a \<Rightarrow> bool) \<Rightarrow> 'a setCollect 'a \<Rightarrow> boolD \<inter> (('a \<times> 'a) list \<Rightarrow> ('a \<times> 'a) setset ('a \<times> 'a) listl)\<^sup>*``'a list \<Rightarrow> 'a setset 'a listvs\<^sub>0 \<noteq> {}" 
2.At the other end of the spectrum, we can find formalizations that are much easier to understand, have fewer statements, and that are much easier to maintain.\begin{code}fun ty_term' where  "(variable \<Rightarrow> 'a option) \<Rightarrow> (object, 'a) mapping \<Rightarrow> PDDL_STRIPS_Semantics.term \<Rightarrow> 'a optionty_term' variable \<Rightarrow> 'a optionvarT (object, 'a) mappingobjT PDDL_STRIPS_Semantics.termt = (variable \<Rightarrow> 'a option) \<Rightarrow> (object \<Rightarrow> 'a option) \<Rightarrow> PDDL_STRIPS_Semantics.term \<Rightarrow> 'a optionty_term variable \<Rightarrow> 'a optionvarT ((object, 'a) mapping \<Rightarrow> object \<Rightarrow> 'a optionMapping.lookup (object, 'a) mappingobjT) PDDL_STRIPS_Semantics.termt"\end{code}This is a snippet that takes the same definition, but reduces it to 10% of the length.
2. The definition of of_type_refine1 is horribly long, and one would probably want to check it by hand.When assessing the quality of a formalization, we can use the following simple quality metrics.We score formalizations in two ways:1. \textit{Standard}. We compute the total length of the formalization in characters (excluding white space).2. \textit{Normalized}. We divide the total length of the formalization by the number of lemmas in the formalization.Here is an example of a very high-quality formalization.(* Line-breaking: *)"
3.Following \cite{venema_focused_2015}, we can use \texttt{isabelle-reasoner} to evaluate how the formalization was built. The \texttt{reasoner} is a program that takes an Isabelle input file and returns a human-readable report.Let us run it on the file in the previous snippet:\begin{code}$ isabelle-reasoner -QT 1.3 <test.thy>\end{code}The \texttt{reasoner} found 13 errors. Two of them are of type \textit{inconsistency} and 11 of type \textit{missing definition}.Of course, we could fix all of these problems, but at what cost?In conclusion, if we want to make sure that the formalization of our Isabelle theory is of high quality, we need to check if it is consistent and if it makes sense.A good way to check if it is consistent is by using the \texttt{isabelle-reasoner}.\begin{remark}\label{rem:reasoner}A \
7. But there is always room for improvement.
7:\begin{itemize}\item It is quite clear, the syntax is ok, the usage of "_" is ok (it is not "ident", so it is not that hard to read), and it is a fairly short proof.\item The lemmas are fine, but most definitions are missing. The code above is a simplification of a large proof, so it has been greatly simplified. The same is true for the definitions. There are definitely many more to be written.\end{itemize}<a href="https://i.stack.imgur.com/Jq16t.png" rel="nofollow noreferrer"><IMAGE></a>\begin{itemize}\item It is a bit hard to read because of the length of the proof. I would put it in two lines if it was possible.\end{itemize}<a href="https://i.stack.imgur.com/2bFxq.png" rel="nofollow noreferrer"><IMAGE></a>\begin{itemize}\item It is not well maintained, as it relies on something that is no longer available on the Isabelle website.\end{itemize}
5.This formalization was done using Isabelle's toolbox:\begin{itemize}\item \texttt{isabelle} to do the formalization,\item \texttt{isabelle_check} to check the correctness of the formalization,\item \texttt{isabelle_doc} to generate the documentation,\item \texttt{isabelle_doc_latex} to generate the documentation in latex.\end{itemize}If you want to have a more in-depth understanding of how to formalize, we can say that the following steps were taken in this particular case:\begin{itemize}\item We first typed the formulas manually. For example, the following snippet\end{itemize}by (cases predicate \<times> 'ent listpvs) (auto simp: is_of_type'_correct[abs_def] split:option.split)\begin{code}fun wf_atom' :: "_ \<Rightarrow> type'ent atom \<Rightarrow> bool" where  "(char list \<Rightarrow> char list list) \<Rightarrow> 'ent atom \<Rightarrow> boolw
5. This formalization is very clear, understandable, and easy to use.We can also grade a formalization on its size. A huge formalization is bad for the maintainability of the system.\begin{lstlisting}[language=isabelle]lemma p1: "wf_fmla' 'A \<Longrightarrow> atom_formula' 'A \<Longrightarrow> atom' 'A"\end{lstlisting}\begin{lstlisting}[language=isabelle]lemma p2: "wf_fmla' char list \<Longrightarrow> atom' char list"\end{lstlisting}In this case, the second lemma is trivial. It makes little sense to include this, and I would give it a 1.\begin{lstlisting}[language=isabelle]lemma p3: "wf_fmla' char list list \<Longrightarrow> atom' char list list"\end{lstlisting}\begin{lstlisting}[language=isabelle]lemma p4: "wf_fmla' char list list \<Longrightarrow> atom' char
2.We can formalize Isabelle documentation using Isabelle's \verb|doc| tactic. The advantage of this is that the formalization can be automatically included in the Isabelle source code.\begin{verbatim}lemma "lemma3":  "P (a,b) \<longleftrightarrow> (\<lambda>c. \<forall>d. P (c,d) \<longleftrightarrow> (\<lambda>e. P (e,d) \<longleftrightarrow> (\<lambda>f. P (f,d) \<longleftrightarrow> (\<lambda>g. P (g,d) \<longleftrightarrow> (\<lambda>h. P (h,d) \<longleftrightarrow> (\<lambda>i. P (i,d) \<longleftrightarrow> (\<lambda>j. P (j,d) \<longleftrightarrow> (\<lambda>k. P (k,d) \<longleftrightarrow> (\<lambda>l. P (l,d) \<longleftrightarrow> (\<lambda>m. P (m,d) \<longleftrightarrow> (\<lambda>n. P (n,d) \<longleftrightarrow> (\<lambda
3.This is a formalization that can be used by a human, but it is far from ideal.The above snippet is an example of formalization that is acceptable from a human's point of view.There are several criteria we can use to evaluate the quality of a formalization. Let us go through some of them:\begin{itemize}\item {\bf Understandability}\begin{itemize}\item {\bf Understandable} - \em{If the reader can understand a proof, they will be able to understand a program that implements the proof} (Descriptive Terms and Proofs, pg. 4)\item {\bf Readable} - \em{If the proof is hard to read, it is harder to read the program that implements the proof} (Descriptive Terms and Proofs, pg. 5)\item {\bf Maintainable} - \em{If the proof is hard to maintain, it is harder to maintain the program that implements the proof} (Descriptive Terms and Proofs, pg. 5)\end{itemize}\item {\bf Maintainability}
7.'''  defmethod( 'wf_action_schema' , [ 'univ' , 'univ' ] ) =    '''  let (char list \<Rightarrow> char list list) \<Rightarrow> (object, PDDL_STRIPS_Semantics.type) mapping \<Rightarrow> ast_action_schema \<Rightarrow> bool    char list \<Rightarrow> char list liststg (object, PDDL_STRIPS_Semantics.type) mappingconT (char list \<Rightarrow> (variable \<times> PDDL_STRIPS_Semantics.type) list \<Rightarrow> PDDL_STRIPS_Semantics.term atom formula \<Rightarrow> PDDL_STRIPS_Semantics.term ast_effect \<Rightarrow> ast_action_schemaAction_Schema char listn (variable \<times> PDDL_STRIPS_Semantics.type) listparams PDDL_STRIPS_Semantics.term atom formulapre PDDL_STRIPS_Semantics.term ast_effecteff) \<longleftrightarrow> (      let        PDDL
5.\end{code}I would like to have a set of criteria that I can use to grade the quality of formalizations. This set of criteria would be manually written by experts, and would be used to grade formalizations on a set of criteria.Answer: \begin{itemize}\item Understandability\begin{itemize}\item Defining sets of types is ok, but if I had to look for the correct definition of `boolwf_domain' it would take some time to find it.\end{itemize}\item Maintenance\begin{itemize}\item I am sure that Isabelle/HOL will not break and that the code will be readable forever.\end{itemize}\item Ease of use\begin{itemize}\item Not sure what to say here.\end{itemize}\end{itemize}So my grade would be 5.Comment: It is extremely important to have a set of criteria. The authors of Isabelle 2018 say that we do not use Isabelle to check correctness, but to grade the quality of formalizations.
5.The next snippet is much better:lemma wf_domain'_correct: "(char list \<Rightarrow> char list list) \<Rightarrow> (object, PDDL_STRIPS_Semantics.type) mapping \<Rightarrow> boolwf_domain' char list \<Rightarrow> char list listSTG (object, PDDL_STRIPS_Semantics.type) mappingmp_constT = boolwf_domain"    unfolding wf_domain_def wf_domain'_def    by (auto simp: wf_action_schema'_correct)end context ast_domain begin  fun apply_effect_exec    :: "object ast_effect \<Rightarrow> world_model \<Rightarrow> world_model"  where    "object ast_effect \<Rightarrow> object atom formula set \<Rightarrow> object atom formula setapply_effect_exec (object atom formula list \<Rightarrow> object atom formula list \<Rightarrow> object ast_effectEffect object atom formula listd) object atom formula sets      = (object atom formula \<Rightarrow> object atom formula set \<Rightarrow> object atom formula set) \<Rightarrow>
3.Some comments:* We could have split the lemma into two or three more short lemmas.* The most important point is the definition of `apply_effect_exec`. It is not short, but as this is a lemma it is relatively harmless. The definitions of `image_def` and `sup_assoc` are also not that short, but are both very important.* Aside from this, the lemma has some short definitions and a lot of induction.The following snippet is a slight improvement over the previous example. It is still a bit too long, but we have slightly reduced the amount of induction.lemma apply_effect_exec_refine[simp]:    "object ast_effect \<Rightarrow> object atom formula set \<Rightarrow> object atom formula setapply_effect_exec (object ast_effectEffect (object atom formula lista) (object atom formula listd)) object atom formula sets    = object ast_effect \<Rightarrow> object atom formula set \<Rightarrow> object atom formula setapply_effect (object ast_effectEffect (object atom formula lista) (object atom formula listd)) object atom formula sets"  proof(induction object
6.So what exactly makes an Isabelle formalization of high quality? Here is a list of things that we will look at in this tutorial:- Clarity- Readability- Easy to modify- Easy to verify (e.g. to prove correctness)--------------------------------------------------------------------------| **** Exercise 1: Defining `suc' and `isSuc' in Isabelle/HOL ****|- --------------------------------------------------------------------------We want to formalize that for all `n`, there exists `m` such that `suc m = n`. How would you do it?We can do it in two ways: First, we can prove that for some `n` we have `n = succ m`. Then we have to do the same for all `m`, but we cannot do that easily (but see below).Alternatively, we can define `suc` in terms of `isSuc`, `isSuc` in terms of `suc`, and then use induction to prove that `isSuc` is indeed correct.We can define `isS
4.\end{code}This snippet is a good example of a well defined, but not so well written Isabelle proof.\section{Writing Isabelle proofs is hard}The reason I am making this claim is that I've been learning about formal verification, and writing proofs in Isabelle for a while now.When I started out, I thought that writing a proof was relatively easy. After a while, I learned that writing proofs in Isabelle is much more involved than I initially thought.Writing a simple proof in Isabelle is not trivial. Writing a proof in Isabelle is hard.I will present a proof for a simple problem, and explain why it is not trivial to prove this.\section{Example 1: Implementing f(x) = x \+ 1}Let us define the function `f` which takes a number `x` and returns the number `x` plus one.\begin{code}structure f (S:Set) (x:S)  def f: S->S    = x + 1lemma f_injective[simp]:
6.From the Isabelle user's perspective, the full formalization of a specification can be seen as the product of several quality components:\begin{itemize}\item Understandability\item Maintainability\item Efficiency\end{itemize}Maintainability is a difficult one to measure, as it requires both an understanding of the specification and a knowledge of the Isabelle/HOL system.Understandability can be measured by the difficulty of reading the formalization, and the number of bugs that it has, at least in the case of formalizations that have been around for a while.Efficiency can be measured by the performance of the Isabelle/HOL tools in compiling a formalization, and by the relative size of the formalization in comparison to its verification time.\subsubsection{Formalizing Operational Semantics}The Isabelle/HOL system is typically used to formalize a specification as a formal language with operational semantics. The operational semantics are then used to prove the desired properties.Thus, the operational semantics of a formal language are formalized using Isabelle/HOL.
3.Now let's look at the same snippet, but formalized using SMTLib.\begin{code}definition "map (char \<Rightarrow> char list) (char list \<Rightarrow> char list list) \<equiv>    (char \<Rightarrow> char list) \<Rightarrow> (char list \<Rightarrow> char list list) mapping \<Rightarrow>    (char list \<Rightarrow> char list list) mapping \<Rightarrow> boolwf_domain' (char list) \<Rightarrow>    char list liststg (char list \<Rightarrow> char list list) mappingconT (char list \<Rightarrow> char list list) mappingmpend"lemma "map (char \<Rightarrow> char list) (char list \<Rightarrow> char list list) (map (char \<Rightarrow> char list) (char list \<Rightarrow> char list list)) (map (char \<Rightarrow> char list) (char list \<Rightarrow> char list list))"  apply (rule dom_rec)  apply simp  apply (simp add: map_def set_def)  apply (rule map_def)  done\end{code}
2, but that is not really fair. It should be much higher.\end{code}Comment: I would say that this is a good example of the ambiguity that you speak of. The 300 lines of context and the 20 lines of definitions and lemmas are important and I should not have to skim through to find the gold in the pages. I don't want to waste people's time, so I've put in a lot of effort to make the context and definitions as concise as possible. The focus on these is not the right place.Comment: The last 10 lines are what I'm trying to say. I don't want to waste people's time, so I've put in a lot of effort to make the context and definitions as concise as possible. The focus on these is not the right place. The focus should be on how good the proof is. This could be at 100% but we'll never know because we can't see the proof.
6.How do we improve it? * Definition X1 and X2 could be rephrased in a more compact way. * The definition of bool?thesis needs to be improved. * The definition of bool?thesis needs to be improved. * The definition of bool?thesis needs to be improved. * Proofs should be kept short. * Improve readability. * Define "index_by_eq_Some_eq" instead of duplicating "index_by". * Try to make it more concise. * Define "index_by_eq_Some_eq" instead of duplicating "index_by". * Define "index_by_eq_Some_eq" instead of duplicating "index_by". * Define "index_by_eq_Some_eq" instead of duplicating "index_by".Here is a possible improved version:context ast_domain begin  definition "char list \<Rightarrow> (unit \<Rightarrow> char list \<Rightarrow> char list) + ast_action_schemaresolve_action_schemaE char listn \<equiv>    ast
6.
5: It is fine for now but it is not great. Let us make it better.First, let us clarify the purpose of the function. It is just a proof that the action is enabled if and only if the semantics of the action matches the semantics of the plan, i.e., that the action can be executed. This is important because the semantics of the action is required when querying the behavior of the action.\begin{figure}[h]\begin{center}\fbox{\includegraphics[width=0.7\textwidth]{figures/wf_ast_problem.pdf}}\end{center}\caption{A fragment of the Isabelle/HOL definition of the PDDL problem ``wf_ast_problem''}\label{fig:wf_ast_problem}\end{figure}Let us look at the definition of the action semantics in Isabelle/HOL. It is defined by using an implicit function that calculates the set of sequences of actions that can be executed for a given state:\begin{figure}[h]\begin{center}\fbox{\includegraphics[width=0.
5.\vspace{1em}\noindent\textbf{A}utomated \textbf{Q}uality \textbf{E}valuation (\textbf{AQE})~\cite{vester1999modelchecking} and Automated \textbf{Q}uality \textbf{A}ssessment (\textbf{AQA})~\cite{vester1999modelchecking,vester1998automated} are two well-known approaches to assess the quality of formalizations.\vspace{1em}AQE is a tool that automatically generates a quality score for a formalization. AQA evaluates a formalization using some specified metric.These tools are relatively old, but we need not be concerned about that. There have been a number of recent improvements~\cite{DBLP:conf/lpar/SchaerfSF14,DBLP:conf/lpar/ShkatuloHSPS16}.The metric is specified by a formula of the form $met[\alpha]$ where $\alpha$ is a formula for the quality and $met$ is a metric.
5.\end{description}\end{document}\end{code}Comment: When I do that, I get an error: ! Package exptr-tlm 0.3.0 is not installed.Comment: @DiaaEl-Sayed The exptr-tlm package needs to be installed. You need to add it to the list of packages.Comment: I did, the document is still not compilingComment: @DiaaEl-Sayed I tested it with exactly the same setup as you, and it compiles and runs. What version of pdflatex and latex are you using?Comment: @DiaaEl-Sayed You could try to compile it with `xelatex` instead of `pdflatex`, but this might make it more difficult to debug.Comment: @DiaaEl-Sayed I updated my answer, so that the example compiles using `pdflatex`.Comment: Thanks a lot, I'm trying to do it with xelatex now, I'll let you knowComment: @Dia
6.It is readable, but not very straightforward.To improve this, we should keep the following things in mind:\begin{itemize}\item When writing the formalization, use the Isabelle theorem prover as if it was a programming language.\item When we write a proof, it is important to make it readable and intuitive.\item When we write a proof, we should make sure that it is general, i.e. the proof works for all possible inputs.\item When we write a proof, we should make sure that it is small and efficient.\end{itemize}Isabelle can be used as a programming language, and this can be seen in the following example:\begin{code}lemma (in wf_ast_problem) en_exE2_return_iff_compact_notation:  "\<lbrakk>object atom formula set \<Rightarrow> boolwm_basic object atom formula sets\<rbrakk> \<Longrightarrow>    (char list \<Rightarrow> char list list) \<Rightarrow> (object, PDDL_STRIPS_Semantics.type) mapping \<Rightarrow> plan
10/10. The formalization is very good.However, the following formalization is not correct.lemma valid_plan_from1: "object atom formula set \<Rightarrow> plan_action list \<Rightarrow> boolvalid_plan_from object atom formula sets plan_action list\<pi>s"  proof(induction plan_action list\<pi>s arbitrary: object atom formula sets)    case Nil    then show bool?case by (auto simp add: plan_action_path_def valid_plan_from_def)  next    case (Cons a \<pi>s)    then show bool?case      by (auto        simp: valid_plan_from_def plan_action_path_def plan_action_enabled_def        simp: execute_ground_action_def execute_plan_action_def)  qed  fun valid_plan_fromE    :: "_ \<Rightarrow> (object, type) mapping \<Rightarrow> nat \<Rightarrow> world_model \<Rightarrow> plan \<Rightarrow> _+unit"  where    "(char list \<Rightarrow> char list list) \<
5.You may already have noticed that this definition is not very nice. It is a bit verbose, hard to understand, and it is not clear why you need an object action. It also has too many definitions and lemmas.This is why Isabelle-14.3 contains new features that make formalizations of this quality easier to create.We can make formalizations more understandable by using them to derive theorems that explain what they do.The following theorems explain the correctness of the previous snippet:lemma (in wf_ast_problem) wf_actions_only_add_atoms':    "\<lbrakk> object atom formula set \<Rightarrow> boolwm_basic object atom formula sets; plan_action \<Rightarrow> boolwf_plan_action plan_actiona \<rbrakk>      \<Longrightarrow> object atom formula set \<Rightarrow> boolwm_basic (plan_action \<Rightarrow> object atom formula set \<Rightarrow> object atom formula setexecute_plan_action plan_actiona object atom formula sets)"    using wf_problem wf_domain    unfolding wf_problem_def
9. It is quite clear and understandable, and it is easy to follow.A formalization is good if it is correct, readable, and maintainable."""# show the correctness of the snippetlemma valid_plan_fromE_return_iff:  assumes valid_plan_fromE: "valid_plan_fromE \<le> objT listP_eq_iff mp"  and valid_plan_fromE_return_iff: "\<forall>s\<equiv>(obj, mp')\<in>list\<gamma>map\<gamma>set.  valid_plan_fromE s \<Longrightarrow> valid_plan_fromE s \<equiv> valid_plan_fromE s' \<Longrightarrow> valid_plan_fromE s' \<Longrightarrow> valid_plan_fromE (s', mp') \<Longrightarrow> valid_plan_fromE (s', mp') \<Longrightarrow> valid_plan_fromE s' \<Longrightarrow> valid_plan_fromE s'"  and valid_plan_fromE_return_iff': "valid_plan_fromE_return_iff[of objT mp' objT mp']
6:\begin{itemize}\item Understandable: You can see that the lemma is not too long.\item Maintainable: It is not too difficult to find the definition or lemma and to understand it.\item Easy to use: The definition of check_all_list_return_iff is not too complex and can be used without thinking much about it.\end{itemize}We can make it a 7 by commenting it as follows:\begin{code}lemma check_all_list_return_iff[return_iff]: "('b \<Rightarrow> bool) \<Rightarrow> 'b list \<Rightarrow> 'c \<Rightarrow> ('b \<Rightarrow> 'a \<Rightarrow> char list) \<Rightarrow> (unit \<Rightarrow> 'a \<Rightarrow> char list) + unitcheck_all_list 'b \<Rightarrow> boolP 'b listl 'cmsg 'b \<Rightarrow> 'a \<Rightarrow> char listmsgf = unit \<Rightarrow> (unit \<Rightarrow> 'a \<Rightarrow> char list) + unitInr () \<longleftrightarrow> (\<forall>'bx\<in>'b list \<Rightarrow>
5."""def check_quasi_continuity(f0: FormalProof): Unit =  let    "f1"  = List.map (fun c => f0.get_term(c))  in  if List.all (fun x => f1(x) = f0.get_term(x)) then    return ()  else    fail "quasi-continuity violation"def check_formal_lemma(lemma: FormalProof): Unit =  let    "v" = lemma.get_term  in  if v.is_well_typed then    if lemma.is_correct() then      return ()    else      let        "res" = lemma.correct      in      if res.is_well_typed then        return ()      else        fail "formal lemma is not correct"    end  else    fail "formal lemma is not well typed"def check_formal_lemma_wf_types(lemma: FormalProof): Unit =  if
7.The previous snippet was not easy to read. We need to be able to read a formalization and understand what it does. We also want to be able to easily change or maintain it.We can use a technique called formal-equivalence to compare two formalizations and decide if they are functionally equivalent. We can use Isabelle's formal-equivalence feature which takes two formalizations and compares them. It reports if they are equivalent, and if they are not, it reports the differences between them.Let us take another snippet as an example, the same one with the formal-equivalence feature:lemma check_wf_domain_return_iff[return_iff]:  "ast_domain \<Rightarrow> (char list \<Rightarrow> char list list) \<Rightarrow> (object, PDDL_STRIPS_Semantics.type) mapping \<Rightarrow> (unit \<Rightarrow> char list \<Rightarrow> char list) + unitcheck_wf_domain ast_domainD char list \<Rightarrow> char list liststg (object, PDDL_STRIPS_Semantics.type) mappingconT = unit \<Rightarrow> (
5. It is understandable and maintainable, but if we could add some extra annotations it would make it even better, for example by adding the meaning of the lemmas and definitions in the comments.\section{Quality assurance}We are now ready to define formalization quality as a numerical value.\begin{defn}The \textbf{quality} of a formalization $f$ is defined as:\begin{align*}Q(f) = 100 * f_gold - f_clean\end{align*}\end{defn}Here $f_gold$ is the quality of the formalization if the author was able to write it without any help, and $f_clean$ is the quality of the formalization if all the code was written by Isabelle.To get a good intuition, let us look at some examples:\begin{exmpl}\label{ex:formalization_of_a_bunch_of_lemmas}We now formalize a bunch of lemmas in the Isabelle/HOL library, using Isabelle's \texttt{assert
5.\subsection{Typing of Isabelle Expressions}We would also like to have the ability to evaluate Isabelle expressions in a typed way.Here is an example of a type definition for integers:\begin{code}def nat_type =  type of Nat\end{code}This definition is automatically inserted into the Isabelle world model for free. The following snippet will print the type of a given integer in the output:\begin{code}definition nat_of_int (n : nat) : nat :=  if n = 0 then 0  else n + nat_of_int (n-1)\end{code}The advantage of this approach is that we no longer need to care about writing type annotations in Isabelle code. Instead we can just write out the type and have it inserted automatically.\subsection{Isabelle Libraries and Types}Isabelle provides a large number of libraries and types. Some of these are quite useful to have around, especially for the Isabelle user. However, a large number of them are not documented at all.By defining our
5.The main problem here is the lack of documentation. An Isabelle file is a collection of definitions and proofs. Without documentation, the file is only a collection of definitions and proofs.An Isabelle file is a collection of definitions and proofs. Without documentation, the file is only a collection of definitions and proofs.It is usually the case that one is interested in a particular definition or proof. Without proper documentation, finding these definitions and proofs becomes a time-consuming task.There are many methods and tools to do this, but they all share the same idea. If you are interested in something, you need to find it using some kind of search function or method.As we all know, search functions are a time-consuming task.The basic idea of good documentation is to be as concise as possible, but also to describe what a particular definition or proof is doing. It should be easy to find what you are interested in.If you know what a particular definition or proof is doing, then it is easy to read it and understand it.If you do not know what a particular definition or proof is doing, then it is a lot harder to understand it.It is also hard to
5.\end{code}The particular problem with this snippet is that the definition of `distinct_ds_def` uses the following lemma:\begin{code}lemma [code_unfold]: "'a list \<Rightarrow> booldistinct = 'a list \<Rightarrow> booldistinct_ds"  apply (intro ext)  unfolding distinct_ds_def  apply (auto simp: sorted_no_stutter_eq_distinct)  done\end{code}The definition of `distinct_ds_def` is defined by the following code:\begin{code}lemma distinct_ds_def: "distinct_ds (distinct_ds xs) = xs"  by (simp add: booldistinct_def)\end{code}The problem is that this definition uses the lemma `booldistinct_ds`, but `distinct_ds_def` is defined \em{before} `booldistinct_ds` is defined.This is a valid Isabelle proof:\begin{code}lemma distinct_ds_
2.\subsection{Related Work}\label{subsec:related}Another related work is the work of Martin-Löf on logic programming and type theory \cite{ML82}. This work is very closely related to the work presented here.Isabelle works with the type theory of Martin-Löf \cite{ML82}.Type theory is a branch of mathematics in which types are used as the main building blocks.In logic programming, type theory is used to model sets of answers to a given set of questions.In this paper, Isabelle is used as a formal tool to verify the correctness of a type theory.There are several other works related to this one.The most closely related work is of course the literature of Isabelle/HOL, the implementation of type theory in Isabelle \cite{Otten07,HOL}.The formalization of type theory in Isabelle is done in the same style as this paper.That is, proofs are given as Isabelle proofs and type theory is formalized in a meta-logical setting.One of the first approaches to type theory in Isabelle was done by
4.In the next section, we will discuss the problems with this snippet, and how they can be solved.******************************************************************************(* Proof summary *)We want to define an abbreviation that works exactly like the predicate in thedefinition of the classical entailment relation.That means that the predicate is used exactly like in the entailment relationdefinition, but the parameters are different.It means that we can use the following syntax:  entail_eq state action proofWhere the state and the proof are used as parameters to the predicate.A proof is a proof of the entailment relation, which is:  E_state_action (Proof,State,Action)This is a function that takes three arguments:  state: The state in which the action is performed.  proof: A proof.  action: The action performed.The predicate should take a similar function that does the same thing, exceptfor the state and proof.If this function is correct, then we can say the following:  entail_eq pred state proofWhen we use the abbre
7.\end{lstlisting}A formalization is only considered correct if it conforms to the semantics, i.e., the Isabelle user should be able to interpret it. If the formalization is not understandable, the Isabelle user is likely to spend more time understanding what the formalization means rather than proving that it is correct.Formalization can be achieved in a number of ways, but some forms of formalization are more maintainable than others.The formalization in the snippet above has three problems:\begin{enumerate}\item \textit{Unclear definitions.} The first three lines are confusing, as there is no obvious way to tell what the definition is about.\item \textit{Proofs that are too hard to follow.} It is easy to get lost in the proof of soundness.\item \textit{Proofs that are likely to break with future changes.} The proof that $\mathbb{B}$ is a domain is only correct for the Isabelle version it was written for. As a result, the code may not compile if this version is upgraded.\end{enumerate}There are also some examples of good form
5. It would be a 10 if the definitions and lemmas were all present.Isabelle provides an extension to the proof environment, using \verb|<definition>|. A \verb|<definition>| declaration can be used to define a named formalization. A named formalization can be used in the \verb|proof| environment, or in \verb|<definition>| declarations.
6.This snippet, when compiled, has 518 lines of Isabelle code.This is far too long for my taste, and it could be significantly shorter.My question is: What is the best way to achieve a shorter formalization?ThanksComment: I do not know enough of the language to answer this, but I'd say that the number of lines is not a quality measure. It is not a measure of readability. It is not a measure of abstraction. It is not a measure of maintainability. The number of lines is just a measure of the amount of code. It can be a useful measure to have if you are trying to calculate how long your code takes to compile, but that is a different question.Comment: @pureferret: I am not sure I agree with you. Compiling times are a different issue and I am not interested in that. I am interested in the readability and maintainability of the code.Comment: @pureferret I'm not sure why you're suggesting the compile time measure doesn't matter. There's no doubt that a huge codebase can be very hard to work on, even
3.The definition is not clear, the proofs are not easily followed, and it can easily be broken by future changes.Another example might be:lemma Int_is_even:  "Int = 42"  unfolding Int_def by simpThis proves that the definition of `Int' is flawed. But it is the only way of proving that.Let's take a step back and think about the underlying problem that we are trying to solve: We are trying to prove that our formalization is correct.The best way to achieve this is to create an extremely clear, well-written, maintainable, and unambiguous formalization.A well-written formalization should be self-documenting.For example, instead of using `Int_is_even' to prove that `Int' is flawed, we should use the definition of `Int' to prove that `Int' is flawed.Let us define a new lemma `Int_is_even_def' that proves that the definition of `Int' is flawed:lemma Int_is_even_def:  "Int \<equiv> 4
5.Here are some things that would make this formalization better.\begin{itemize}\item \strong{Use proper notation.}\begin{itemize}\item `Monoid` should not be called `monoid`.\item `apply` should not be called `apply` (it is too similar to the `apply` function in standard logic).\item `by` should not be called `by` (it is too similar to the `by` function in standard logic).\item `compose_action` should not be called `compose_action`.\item `optioncompose_action` should not be called `optioncompose_action`.\item `option` should not be called `option`.\item `optionSome` should not be called `optionSome`.\item `option` should not be called `option`.\item `apply_option` should not be called `apply_option`.\item `by_option` should not be called `by_option`.\item `option_of_option` should not be called `option_of_option`.\item `option_of_option` should not be
7.\subsubsection{Documentation}\subsubsection{Testing}We can test our formalization by checking if it satisfies the properties of the [Semantic Testing Interface](http://rosettacode.org/wiki/Semantic_testing_interface)\section{Tips and tricks}\subsection{Tips}\subsubsection{Using the Semantic Interface}The Semantic Interface is a formalization of the semantic interface of the [Roots of SAT](http://rosettacode.org/wiki/Roots_of_SAT) proof assistant. It is often a good starting point as it includes many useful definitions, which can save time when formalizing a new proof assistant.The main advantage of using the Semantic Interface is that it is a widely used and trusted formalization, so if it is correct, so is your formalization. However, it is not 100% bug-free and so it is not totally risk-free.If you do not want to use the Semantic Interface, and you want to formalize your proof assistant on your own, there are some tips that can be helpful.
3.This snippet could be improved with the following changes:* \begin{itemize}\item The definition of wm_basic is defined outside of the proof, it's better to define it in the proof.\item The theorem is actually a lemma, it should be renamed to "wm_basic_is_wm".\item The proofs are too long.\item The proofs are hard to follow.\item The names of the lemmas are cryptic.\end{itemize}We are already at a score of 6. Let us continue:* The proof is split in two parts. It is not really a split, but rather a proof of two properties. If you write:\begin{code}have "(object atom formula set \<Rightarrow> object atom \<Rightarrow> boolvaluation object atom formula setM')" if "object atom formula set \<Rightarrow> boolwm_basic object atom formula setM'"\end{code}and omit the "for fmla" part, then you are left with a proof that wm_basic is a semidecidable relation. But this is
7.One reason for this lower score is that the definition of ground_action is a bit difficult to follow:We use induction over some object \<alpha> to prove the correctness of the function. This is not intuitive and may be confusing for people who are not familiar with Isabelle.We could use a let-bound for the definition:using assms  let _ \<alpha> = ground_action  proof(induction ground_action\<alpha> list\<alpha> arbitrary: predicate \<times> object list \<Rightarrow> bools\<^sub>0 object atom formula setM\<^sub>0 )    case Nil    then show bool?case by (auto simp add: close_world_def compose_action_def sound_system_def)  next    case ass: (Cons \<alpha> \<alpha>s)    then obtain pre add del where a: "ground_action\<alpha> = object atom formula \<Rightarrow> object ast_effect \<Rightarrow> ground_actionGround_Action object atom formulapre (object atom formula list \<Rightarrow> object atom formula list \<Rightarrow> object ast_effectEffect object atom formula listadd object
9.In summary, we can safely use the Isabelle formalization to verify all our (sound) properties of the PUREST library.}\newpage\section{Evaluation}In this section, we evaluate our tool and the library.We will use the following evaluation criteria:\begin{enumerate}\item Clarity of Isabelle formalization\item Efficiency of the Isabelle formalization\item Efficiency of the tool\item Robustness of the tool\item The ability to refactor properties\item User friendliness\end{enumerate}To evaluate the quality of our Isabelle formalization, we use the following criteria:\begin{enumerate}\item Is it understandable?\item Is it maintainable?\item Is it easy to use?\end{enumerate}\subsection{Clarity of the Isabelle Formalization}We will use two informal approaches to evaluate the clarity of the Isabelle formalization. The first is based on the fact that we have implemented some validations in our tool, and thus a single small change to the
5. The definitions and lemmas are not missing on purpose, but this is just a snippet. The full formalization should be a 10.Note that this is just a small snippet. In a full formalization, the quality would be a lot higher.For example, this snippet for the \texttt{World} constructor is from the full formalization of \texttt{PowerSet}.\begin{code}WW<a,b> = ((a \<in> X) \<and> (b \<in> X)) \<and> X = M\end{code}Now, the reader can go ahead and read this. It is somewhat confusing, but the quality is acceptable.However, with \texttt{Set}, the reader can never be sure whether the definition is correct or not. \texttt{Set} is not an inhabited set, so some parts of the definition are not defined. The reader has to assume that the definition is correct.The quality of a formalization is not only important for the user. It also has a large impact on how Isabelle does its verification.\begin{code}Definition \<tau>1 =
9.Isabelle is always capable of generating proofs that are as clear as possible.Of course, the quality of the formalization will still depend on the programmer's choice.However, since we are not limited by the computer's memory, we can be as meticulous as we want.\section{Second example: A poorly formalized correctness proof}Let us now examine a proof that is not correct.Let's say that we want to prove that a function $f$ is correct.This function takes an input $x$ of type $int$ and returns an output $y$ of type $string$.\begin{lstlisting}[language=Isabelle,mathescape=true]definition f (x : int) := "string" (c_concat x 0)\end{lstlisting}The user can either not write the definition correctly (for example by using a string instead of a function), or use a wrong type.In this case, Isabelle will be able to catch the error at the time of the definition, but this is no guarantee that the user will actually do so.We
4. It is not as good as it could be and could be improved.Let us see what we can do to improve this formalization.\end{blockquote}\begin{blockquote}\begin{code}open ass.IH      open ass.prems      let ?M = some_assumption      let ?M' = some_assumption_map ?M      let ?M'' = ?M' setclose_world      let ?a = (some_assumption_map ?M') setclose_world ?M      let ?f = predicate \<times> object list \<Rightarrow> bool      let ?f' = predicate \<times> object list \<Rightarrow> bool      let ?a' = ?M' setclose_world ?a      let ?a'' = ?M' setclose_world ?a'      let ?b = ?a'' list      let ?b' = ?a' listmap ?f      let ?b'' = ?a'' listmap ?f'      let ?e = ?M' list      let ?e' = ?M' listmap ?f
10, but that's just me.*[[Back to the top]]
2.However, let us improve it:  lemma wm_to_state_eq[simp]: "object atom formula set \<Rightarrow> predicate \<times> object list \<Rightarrow> boolwm_to_state object atom formula setM (predicatep, object listas) \<longleftrightarrow> object atom \<Rightarrow> object atom formulaAtom (predicate \<Rightarrow> object list \<Rightarrow> object atompredAtm predicatep object listas) \<in> object atom formula setM"    by (auto simp: wm_to_state_def)This is much better, but it still has room for improvement. We can add some documentation:  lemma wm_to_state_eq[simp]: "object atom formula set \<Rightarrow> predicate \<times> object list \<Rightarrow> boolwm_to_state object atom formula setM (predicatep, object listas) \<longleftrightarrow> object atom \<Rightarrow> object atom formulaAtom (predicate \<Rightarrow> object list \<Rightarrow> object atompredAtm predicatep object listas) \<in> object atom formula setM"    by (auto simp:
4.\end{document}\end{code}I would like to have the following result:<a href="https://i.stack.imgur.com/JMJ2P.png" rel="nofollow noreferrer"><IMAGE></a>I tried different things with \begin{code}\noindent\hrulefill\end{code} and some other stuff but nothing helped.Answer: One way to solve this is to place the `\noindent` after `\end{document}`.\begin{code}\documentclass{article}\begin{document}\begin{tikzpicture}[  scale=1.5,  line cap=round,  line join=round]\begin{scope}[every node/.style={draw,circle,inner sep=1pt}]\node[label=above:{$(0,0)$}] (0) at (0,0) {};\node[label=above:{$(1,0)$}] (1) at (1,0) {};\node[label=above:{$(1,1)$}] (2) at (
10. However, if we rewrote it slightly, we could get a 12.The Isabelle online editor makes it easy to change the quality of a formalization. We can adjust definitions and change lemmas until the formalization is of the best quality.\end{blockquote}Comment: Isn't this the main point of the question? I'd be happy to explain what I mean, but I am not sure I understand what you mean, either.Comment: @user48983, I edited my question to better explain what I mean.Comment: Thanks. What do you mean by "The Isabelle online editor makes it easy to change the quality of a formalization."?Comment: @user48983, I edited my question to explain.Comment: I see. I agree with what you wrote, but I don't understand what you mean by "quality of a formalization". I'm not sure how it differs from "correctness of a formalization".Comment: @user48983, I edited my question to explain.Answer: I agree with you in that it is
1.It is not very clear what all the variables are. It is hard to read, and not clear if there are any special assumptions or properties (e.g., the "object atom formula listd").Let us now take the following snippet, which is a little better, as it has some definitions, a lemma, and some assumptions:\begin{code}using assms    by autolemma adds_satisfied:  assumes "object atom formulaf \<in> (object atom formula list \<Rightarrow> object atom formula setset object atom formula list)"  shows "object atom formulaf \<in> object ast_effect \<Rightarrow> object atom formula set \<Rightarrow> object atom formula setapply_effect (object atom formula list \<Rightarrow> object atom formula list \<Rightarrow> object ast_effectEffect object atom formula lista object atom formula list)"  using assms  by autolemma dels_unsatisfied:  assumes "object atom formulaf \<in> (object atom formula list \<Rightarrow> object atom formula setset object atom formula listd)"  assumes "object atom formulaf \<notin> object atom formula list \<
10. I find it very easy to read and understand.\end{code}\section{What I tried to do}I wanted to replace the definition of the lemma `wf_act_adds_dels_atoms` with an automatically generated lemma. I tried to use [Z3Py](https://github.com/Z3Prover/z3py) to check if the formulae `formulaae` can be satisfiable or not.For some reason this doesn't work and I get the following error:\begin{code}>>> z3 = Z3Prover('C:\\Z3\\z3-3.3.4')Traceback (most recent call last):  File "<stdin>", line 1, in <module>  File "C:\Z3\z3-3.3.4\python\z3prover\z3prover.py", line 1939, in __init__    self.solver = Solver(self.solver_config, self.verbose)  File "C:\Z3\z3-3
5 (it is correct and correct). This quality is not very high, as we would like the formalization to be clear, maintainable, and easy to use.The \texttt{split} and \texttt{Let} primitive used here illustrate the power of our meta-logics and the fact that the user does not need to know the semantics.We simply use \texttt{pddl_opr_to_act} to translate the semantics. This function can be used with many different logic families and the semantics will be different for each of them.The \texttt{Let} primitive allows us to use two different predicates in the same definition.However, one could argue that we could also just use the \texttt{split} primitive to replace the \texttt{Let}.On the other hand, the \texttt{split} primitive is not very convenient. For example, if we want to use it to define some predicates we have to state them in a definition first and then use \texttt{split} for each predicate. This is not very convenient.On the other hand, the \texttt{Let} primitive has more features and could be more convenient than the \texttt{
4.The first thing to notice is that the `using` clauses are too long. The first `using` clause in particular is too long, and does not tell us much about the preconditions used.It would be better to say something like\begin{code}using assmsby (cases object ast_effecteff    ( cases object atom formulaatm        ( cases object atom formulaatom            ( force simp: close_eq_def wm_to_state_def state_to_wm_def split: atom.splits            )        )    )    ( force simp: close_eq_def wm_to_state_def state_to_wm_def split: atom.splits    )    )\end{code}The `using` clauses are saying that we are using the \em{definition} of the case, and that the case is to be solved with the definition. This is not useful. It is also a bit of a code smell, that we need to do this for every definition.The `case` is far too long as well, and doesn
4.\end{blockquote}\strong{So, what would be the best way to approach this?}\section{Question}Is there a good way to assess and measure the quality of a formalization? If so, how would you go about it?Comment: See also http://cs.stackexchange.com/q/50038/755Comment: @TimCouwelier I have checked that question, and I don't think it really answers my question.Answer: I would say that a formalization should be at least be correct, at most interesting, and ideally both correct and interesting.If you want to measure the interest of a formalization, you can try to consider its potential for reuse (e.g., is it part of a library you are maintaining? is it written by someone else? is it related to my own work?).But beware that just because you think your formalization is interesting, it does not mean that others will agree with you.Comment: The problem is, that it is not always clear how the quality of a formalization relates to the quality of the content it formal
3.\end{code}For the record, this snippet is taken from a tutorial, that was a good place to start.Now I am trying to formalize a \em{SAT} solver, and this time I want to do it right. I am not going to write a snippet that includes all the definitions and lemmas that the SAT solver needs, but I want it to look nice.Unfortunately, the Isabelle documentation does not help much in this case. It seems that Isabelle is only able to formalize correct, correct, but not correct.To formalize the SAT solver, I am going to use the module `isabelle_checker`. I found the module [here](https://github.com/isabelle/isabelle/blob/master/isabelle_checker/src/isabelle_checker/test.ml) on the Isabelle repository. I have modified the `wf_fmla_atm_is_atom` lemma to include a list of atoms to prove that it is a valid SAT solver.Isabelle does not seem to be able to verify the
5.\end{document}\end{code}Comment: Have you looked into the `verbatim` package?Comment: I have not looked at it.  I do not think it helps in this case.  I am not looking for a solution that allows me to use verbatim environment.  I am looking for a way to modify the code to get rid of the verbatim environment altogether.Answer: You can use the `showboxes` package, with the `noverbatim` option.  This example shows the `verbatim` environment and the `noverbatim` environment.  If you want a different colour for the noverbatim environment, you can use the `showboxes` package as described here: [How to change the color of a box environment in LaTeX?](https://tex.stackexchange.com/questions/257248/how-to-change-the-color-of-a-box-environment-in-latex)\begin{code}\documentclass{article}\usepackage[utf8]{inputenc}\usepackage{amssymb}\usepackage
